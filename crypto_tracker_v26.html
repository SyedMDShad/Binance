<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Live Crypto Tracker v26</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 8px; }
    #clock-bd { font-size: 1em; font-weight: bold; margin-bottom: 4px; color: #0070f3; }
    #timestamp, #error, #error-metrics { font-size: 0.9em; color: #555; margin-bottom: 4px; }
    #metrics { font-size: 0.9em; color: #333; margin-bottom: 6px; }
    .mcap-positive { color: green; }
    .mcap-negative { color: red; }
    .sortable { cursor: pointer; text-decoration: underline; }
    table { width: 100%; border-collapse: collapse; margin-top: 6px; }
    th, td { border: 1px solid #ddd; padding: 4px; text-align: right; font-size: 0.9em; }
    th { background-color: #f4f4f4; text-align: left; }
    .highlight-btc { background-color: #FEE2E2; }
    .highlight-top4 { background-color: #FEF3C7; }
    .rsi { font-size: 0.8em; }
    .rsi.red { color: red; }
    .rsi.green { color: green; }
  </style>
</head>
<body>
  <div id="clock-bd">BD Time: --:--:--</div>
  <div id="timestamp">Loading...</div>
  <div id="metrics"></div>
  <div id="error-metrics"></div>
  <div id="error"></div>
  <table>
    <thead>
      <tr>
        <th class="sortable" id="sort-coin">Coin</th>
        <th class="sortable" id="sort-rsi">RSI (15m)</th>
        <th class="sortable" id="sort-low">24h Low</th>
        <th class="sortable" id="sort-high">24h High</th>
        <th class="sortable" id="sort-last">Current</th>
        <th class="sortable" id="sort-pH">$1,000 (Lowâ†’High)</th>
        <th class="sortable" id="sort-pCH">$1,000 (Currentâ†’High)</th>
        <th class="sortable" id="sort-type">Type & Risk</th>
      </tr>
    </thead>
    <tbody id="crypto-body"></tbody>
  </table>
  <script>
    function updateBdClock() {
      const now = new Date();
      document.getElementById('clock-bd').textContent =
        'BD Time: ' + now.toLocaleTimeString('en-US',{timeZone:'Asia/Dhaka',hour12:true});
    }
    setInterval(updateBdClock, 1000);

    let sortKey = 'pH', sortDir = -1;
    ['coin','rsi','low','high','last','pH','pCH','type'].forEach(k=>{
      document.getElementById('sort-'+k).onclick = () => {
        sortKey = k; sortDir = sortDir * (sortKey === k ? -1 : 1);
        renderTable();
      };
    });

    const precision = {
      BTCUSDT:2, ETHUSDT:2, TRUMPUSDT:2, DOTUSDT:2,
      SOLUSDT:2, AUCTIONUSDT:2, LINKUSDT:2, BCHUSDT:2,
      PNUTUSDT:5, SUIUSDT:4, XRPUSDT:4,
      GUNUSDT:3, BABYUSDT:3, ONDOUSDT:4, DOGEUSDT:5, XLMUSDT:4, ADAUSDT:4,
      TONUSDT:2, ORCAUSDT:2, BERAUSDT:2, ENAUSDT:4,
      PEPEUSDT:8, SHIBUSDT:8, WIFUSDT:4, MOVEUSDT:4
    };

    const coins = [
      {symbol:'BTCUSDT', name:'BTC', label:'Layer 1 âš–ï¸', highlight:'btc'},
      {symbol:'PEPEUSDT',name:'PEPE',label:'Meme ðŸ˜‚',highlight:'top4'},
      {symbol:'XRPUSDT',name:'XRP',label:'Payments ðŸ’³',highlight:'top4'},
      {symbol:'SUIUSDT',name:'SUI',label:'Layer 1 âš–ï¸',highlight:'top4'},
      {symbol:'WIFUSDT',name:'WIF',label:'Meme ðŸŽ‰'},
      {symbol:'BABYUSDT',name:'BABY',label:'DeFi ðŸŸ '},
      {symbol:'ORCAUSDT',name:'ORCA',label:'DeFi ðŸŸ¡'},
      {symbol:'GUNUSDT',name:'GUN',label:'Utility ðŸ”§'},
      {symbol:'PNUTUSDT',name:'PNUT',label:'Meme ðŸ˜‚'},
      {symbol:'MOVEUSDT',name:'MOVE',label:'Layer 2 ðŸ”µ'},
      {symbol:'SHIBUSDT',name:'SHIB',label:'Meme ðŸ˜‚'},
      {symbol:'SOLUSDT',name:'SOL',label:'Layer 1 âš–ï¸'},
      {symbol:'TRUMPUSDT',name:'TRUMP',label:'Meme ðŸ˜‚'},
      {symbol:'BCHUSDT',name:'BCH',label:'Fork ðŸ´'},
      {symbol:'ENAUSDT',name:'ENA',label:'DeFi ðŸ¦'},
      {symbol:'DOGEUSDT',name:'DOGE',label:'Meme ðŸ˜‚'},
      {symbol:'ADAUSDT',name:'ADA',label:'Layer 1 âš–ï¸'},
      {symbol:'TONUSDT',name:'TON',label:'Layer 1 âš–ï¸'},
      {symbol:'AUCTIONUSDT',name:'AUCTION',label:'DeFi ðŸ¦'},
      {symbol:'ONDOUSDT',name:'ONDO',label:'DeFi ðŸ”µ'},
      {symbol:'DOTUSDT',name:'DOT',label:'Layer 1 âš–ï¸'},
      {symbol:'LINKUSDT',name:'LINK',label:'Oracle ðŸ“Š'},
      {symbol:'XLMUSDT',name:'XLM',label:'Payments ðŸ’³'},
      {symbol:'ETHUSDT',name:'ETH',label:'Layer 1 âš–ï¸'},
      {symbol:'BERAUSDT',name:'BERA',label:'Layer 1 âš–ï¸'}
    ];

    async function fetchMetrics() {
      try {
        const [g, f] = await Promise.all([
          fetch('https://api.coingecko.com/api/v3/global').then(r => r.json()),
          fetch('https://api.alternative.me/fng/?limit=1').then(r => r.json())
        ]);
        const mcapCh = g.data.market_cap_change_percentage_24h_usd;
        const fgv = parseInt(f.data[0].value), fgc = f.data[0].value_classification;
        document.getElementById('metrics').innerHTML =
          `<div>Total Market Cap: $${(g.data.total_market_cap.usd/1e9).toFixed(2)}B <span class="${mcapCh<0?'mcap-negative':'mcap-positive'}">(${mcapCh.toFixed(2)}%)</span></div>` +
          `<div>Fear & Greed: <span style="color:red;">${fgv}</span> (${fgc})</div>`;
        document.getElementById('error-metrics').textContent = '';
      } catch {
        document.getElementById('error-metrics').textContent = 'Metrics load failed';
      }
    }

    async function calcRSI(sym) {
      const kl = await fetch(`https://api.binance.com/api/v3/klines?symbol=${sym}&interval=15m&limit=15`).then(r=>r.json());
      let gains=0, losses=0;
      const closes = kl.map(c=>+c[4]);
      for (let i=1; i<closes.length; i++) {
        const d = closes[i] - closes[i-1];
        d>0 ? gains+=d : losses-=d;
      }
      const rs = gains/(losses||1);
      return 100-(100/(1+rs));
    }

    let tableData = [];
    async function fetchData() {
      try {
        const arr = await Promise.all(coins.map(async c => {
          const d = await fetch(`https://api.binance.com/api/v3/ticker/24hr?symbol=${c.symbol}`).then(r=>r.json());
          const rsi = await calcRSI(c.symbol);
          return {...c, low:+d.lowPrice, high:+d.highPrice, last:+d.lastPrice, prev:+d.prevClosePrice,
                  pH:((+d.highPrice - +d.lowPrice)/+d.lowPrice)*1000,
                  pCH:((+d.highPrice - +d.lastPrice)/+d.lastPrice)*1000, rsi};
        }));
        tableData = arr;
        renderTable();
        document.getElementById('error').textContent = '';
      } catch {
        document.getElementById('error').textContent = 'Data load failed';
      }
    }

    function fmt(sym, val) {
      const p = precision[sym] || 4;
      return parseFloat(val).toFixed(p);
    }

    function renderTable() {
      const tb = document.getElementById('crypto-body'); tb.innerHTML = '';
      tableData.sort((a,b) => {
        if(a.symbol==='BTCUSDT') return -1;
        if(b.symbol==='BTCUSDT') return 1;
        let va = sortKey==='coin'?a.name: sortKey==='type'?a.label: a[sortKey];
        let vb = sortKey==='coin'?b.name: sortKey==='type'?b.label: b[sortKey];
        if(['low','high','last','pH','pCH','rsi'].includes(sortKey)){
          va=parseFloat(va); vb=parseFloat(vb);
        }
        return (typeof va==='string' ? va.localeCompare(vb) : va-vb) * sortDir;
      });
      tableData.forEach(r => {
        const tr = document.createElement('tr');
        if(r.highlight==='btc') tr.classList.add('highlight-btc');
        if(r.highlight==='top4') tr.classList.add('highlight-top4');
        const pct = ((r.last - r.prev)/r.prev)*100;
        const pctColor = pct<0?'red':'inherit';
        const cls = isNaN(r.rsi)?'' : (r.rsi<30?'green':'') + (r.rsi>70?' red':'');
        tr.innerHTML =
          `<td style="text-align:left"><a href="https://www.binance.com/en/trade/${r.symbol}?type=spot" target="_blank">${r.name}</a> <span style="font-size:0.8em;color:${pctColor}">(${pct.toFixed(1)}%)</span></td>` +
          `<td><span class="rsi ${cls.trim()}">${isNaN(r.rsi)?'â€”':r.rsi.toFixed(1)}</span></td>` +
          `<td>${fmt(r.symbol, r.low)}</td>` +
          `<td>${fmt(r.symbol, r.high)}</td>` +
          `<td>${fmt(r.symbol, r.last)}</td>` +
          `<td>$${r.pH.toFixed(2)}</td>` +
          `<td>$${r.pCH.toFixed(2)}</td>` +
          `<td style="text-align:left">${r.label}</td>`;
        tb.appendChild(tr);
      });
    }

    function updateTimestamp() {
      const now = new Date();
      document.getElementById('timestamp').textContent =
        'Updated: ' + now.toLocaleTimeString('en-US',{timeZone:'America/New_York',hour12:true}) +
        ' NYC | ' + now.toLocaleTimeString('en-US',{timeZone:'Asia/Dhaka',hour12:true}) + ' BDT';
    }

    document.addEventListener('DOMContentLoaded', () => {
      updateBdClock(); fetchMetrics(); fetchData(); updateTimestamp();
      setInterval(() => { updateBdClock(); fetchMetrics(); fetchData(); updateTimestamp(); }, 60000);
    });
  </script>
</body>
</html>