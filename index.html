<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Crypto Tracker + Profit Calculator</title>
  <style>
    body { font-family: Arial, sans-serif; margin:8px; }
    #clock { font-weight: bold; color: #0070f3; }
    #timestamp, #metrics, #error { font-size:0.9em; color:#555; margin:6px 0; }
    table { width:100%; border-collapse:collapse; margin-top:6px; }
    th, td { border:1px solid #ddd; padding:4px; text-align:right; font-size:0.9em; }
    th { background:#f4f4f4; text-align:left; }
    .sortable { cursor:pointer; text-decoration:underline; }
    /* Added clickable class for RSI header and cells */
    .rsi.clickable { cursor:pointer; }
    .rsi.green { color:green; } .rsi.red { color:red; }

    /* Added alternating row colors */
    tbody tr:nth-child(odd) {
        background-color: #ffffff; /* White background for odd rows */
    }
    tbody tr:nth-child(even) {
        background-color: #f9f9f9; /* Light gray background for even rows */
    }

    /* Highlight for clickable suggestion */
    .highlight-suggestion { background-color: #e0e0e0 !important; } /* Light grey highlight */

    /* Custom highlight colors - Full row */
    .highlight-btc-dip { background-color: #ffcccc; } /* Light red for BTC DIP */
    .highlight-pepe-yellow { background-color: #ffffcc; } /* Light yellow for PEPE */
    .highlight-sui-xrp { background-color: #ccffff; } /* Light blue/cyan for SUI/XRP */


    .calc-row { display:flex; gap:4px; align-items:center; }
    .btn { width:24px; height:24px; border:none; background:#ccc; border-radius:4px; cursor:pointer; }
    input[type=number]::-webkit-inner-spin-button,
    input[type=number]::-webkit-outer-spin-button { -webkit-appearance:none; margin:0; }
    input[type=number] { -moz-appearance:textfield; }
    .input { flex:1; padding:4px; border:1px solid #ccc; border-radius:4px; text-align:right; font-size:0.9em; }
    .buy { background:#e6ffed; }
    .sell { background:#ffe6e6; }
    .profit { font-weight:bold; text-align:center; background:#add8e6; color:black; }
    #inv-select {
        flex: 1;
        padding: 4px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 0.9em;
        text-align: right;
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
        background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%2F%3E%3Cpath%20fill%3D%22%23000000%22%20d%3D%22M287%2C114.7L159.2%2C242.5c-8.8%2C8.8-23.2%2C8.8-32%2C0l-128-128c-8.8-8.8-8.8-23.2%2C0-32s23.2-8.8%2C32%2C0l112%2C112l112-112c8.8-8.8%2C23.2-8.8%2C32%2C0S295.8%2C105.9%2C287%2C114.7z%22%2F%3E%3C%2FSVG%3E');
        background-repeat: no-repeat;
        background-position: right 0.5em top 50%;
        background-size: 0.65em auto;
    }
    .profit-positive { color:green; } .profit-negative { color:red; }
    .clickable { cursor:pointer; }
    a { color:inherit; text-decoration:none; }
    /* Small font for suggestion */
    .suggestion { font-size: 0.7em; }
    /* Colors for suggestion text */
    .suggestion.buy-color { color: green; }
    .suggestion.sell-color { color: red; }
    /* Colors for market cap percentage change */
    .pct-green { color: green; }
    .pct-red { color: red; }
  </style>
</head>
<body>
  <div id="clock">BD Time: --:--:--</div>
  <div id="timestamp">Loading...</div>
  <div id="metrics"></div>
  <div id="error"></div>
  <table>
    <thead>
      <tr>
        <td colspan="9">
          <div class="calc-row">
            <button class="btn" onclick="step('fee',-1)">â€“</button>
            <input id="fee" class="input" type="number" value="0.2" step="0.1"/>
            <button class="btn" onclick="step('fee',1)">+</button>
            <select id="inv" class="input" onchange="updateCalc(); renderTable();">
                <option value="25">25</option>
                <option value="50">50</option>
                <option value="100" selected>100</option>
                <option value="200">200</option>
                <option value="300">300</option>
                <option value="400">400</option>
                <option value="500">500</option>
                <option value="1000">1000</option>
                <option value="1500">1500</option>
                <option value="2000">2000</option>
</select>
            <button class="btn" onclick="step('buy',-1)">â€“</button>
            <input id="buy" class="input buy" type="number" step="any" placeholder="Buy"/>
            <button class="btn" onclick="step('buy',1)">+</button>
            <button class="btn" onclick="step('sell',-1)">â€“</button>
            <input id="sell" class="input sell" type="number" step="any" placeholder="Sell"/>
            <button class="btn" onclick="step('sell',1)">+</button>
            <div id="profit" class="input profit">0.00 USDT</div>
          </div>
        </td>
      </tr>
      <tr>
        <th class="sortable" data-key="coin">Coin</th>
        <th class="sortable clickable" data-key="rsi" id="rsiHeader">RSI (15m)</th>
        <th class="sortable" data-key="last">Current</th>
        <th class="sortable" data-key="low">24h Low</th>
        <th class="sortable" data-key="high">24h High</th>
        <th class="sortable" data-key="pH">Profit Low to High</th>
        <th class="sortable" data-key="pCH">Profit Current to High</th>
        <th class="sortable clickable" data-key="suggestion">Suggestion</th>
        <th class="sortable" data-key="type">Type</th>
      </tr>
    </thead>
    <tbody id="body"></tbody>
  </table>

<script>
  // initial sort on Currentâ†’High descending
  let sortKey = 'pCH', sortDir = -1, tableData = [];
  // Only 15m interval needed
  const rsiIntervals = ['15m'];
  let currentRsiInterval = '15m'; // Default and only interval
  // Variable to track the current RSI sorting state: 'custom-asc', 'custom-desc'
  let rsiSortState = 'custom-asc'; // Start with 0-100-0 order

  function tick() {
    const now = new Date();
    document.getElementById('clock').textContent =
      'BD Time: ' + now.toLocaleTimeString('en-US', { timeZone:'Asia/Dhaka', hour12:true });
  }
  setInterval(tick,1000); tick();

  function updateTimestamp() {
    const now = new Date();
    document.getElementById('timestamp').textContent =
      'Updated: ' +
      now.toLocaleTimeString('en-US',{ timeZone:'America/New_York', hour12:true }) +
      ' NYC | ' +
      now.toLocaleTimeString('en-US',{ timeZone:'Asia/Dhaka', hour12:true }) +
      ' BDT';
  }

  // Calculator
  function step(id, dir) {
    const inp = document.getElementById(id);
    let valueStr = inp.value.trim();

    // Handle empty or non-numeric input
    if (valueStr === '' || isNaN(parseFloat(valueStr))) {
        valueStr = "0";
    }

    const decimalIndex = valueStr.indexOf('.');
    const decimalPlaces = decimalIndex === -1 ? 0 : valueStr.length - 1 - decimalIndex;

    // Remove decimal for BigInt calculation
    let numberWithoutDecimal = valueStr.replace('.', '');

    // Handle potential negative sign
    const isNegative = numberWithoutDecimal.startsWith('-');
    if (isNegative) {
        numberWithoutDecimal = numberWithoutDecimal.substring(1);
    }

    let bigIntValue = BigInt(numberWithoutDecimal);
    const stepBigInt = BigInt(1);

    // Perform the step
    bigIntValue = bigIntValue + BigInt(dir) * stepBigInt;

    let steppedValueStr = bigIntValue.toString();

    // Re-insert decimal point and handle sign
    let finalSteppedValueStr;
    if (decimalPlaces > 0) {
        // Pad with leading zeros if necessary
        while (steppedValueStr.length <= decimalPlaces) {
            steppedValueStr = '0' + steppedValueStr;
        }
        const integerPart = steppedValueStr.substring(0, steppedValueStr.length - decimalPlaces);
        const decimalPart = steppedValueStr.substring(steppedValueStr.length - decimalPlaces);
        finalSteppedValueStr = integerPart + '.' + decimalPart;
    } else {
        finalSteppedValueStr = steppedValueStr;
    }

    // Add back the negative sign if it was originally negative and the result is not zero
    if (isNegative && bigIntValue !== BigInt(0)) {
        finalSteppedValueStr = '-' + finalSteppedValueStr;
    } else if (isNegative && bigIntValue === BigInt(0)) {
         // If it was negative and stepped to 0, remove the sign
        finalSteppedValueStr = finalSteppedValueStr.replace('-', '');
    }


    inp.value = finalSteppedValueStr;
    updateCalc();
  }

  function updateCalc() {
    const fee = (parseFloat(document.getElementById('fee').value)||0)/100;
    const inv = parseFloat(document.getElementById('inv').value)||0; // Get value from select
    const buy = parseFloat(document.getElementById('buy').value)||0;
    const sell = parseFloat(document.getElementById('sell').value)||0;
    const coinsAmt = buy>0 ? (inv/buy)*(1-fee) : 0;
    const prof = (coinsAmt*sell*(1-fee)) - inv;
    const pf = document.getElementById('profit');
    pf.textContent = prof.toFixed(2) + ' USDT';
    pf.classList.toggle('profit-positive', prof>=0);
    pf.classList.toggle('profit-negative', prof<0);
  }
  updateCalc();

  // Data
  const precision = {BTCUSDT:2,ETHUSDT:2,TRUMPUSDT:2,DOTUSDT:2,SOLUSDT:2,AUCTIONUSDT:2,LINKUSDT:2,BCHUSDT:2,PNUTUSDT:5,SUIUSDT:4,XRPUSDT:4,GUNUSDT:3,BABYUSDT:3,ONDOUSDT:4,DOGEUSDT:5,XLMUSDT:4,ADAUSDT:4,TONUSDT:2,ORCAUSDT:2,BERAUSDT:2,ENAUSDT:4,PEPEUSDT:8,SHIBUSDT:8,WIFUSDT:4,MOVEUSDT:4};
  const coins = [
    // Updated highlight values
    {symbol:'BTCUSDT',name:'BTC', label:'Layer 1', highlight:'btc-dip'},
    {symbol:'PEPEUSDT',name:'PEPE', label:'Meme ðŸ˜‚', highlight:'pepe-yellow'},
    {symbol:'XRPUSDT',name:'XRP', label:'Payments ðŸ’³', highlight:'sui-xrp'},
    {symbol:'SUIUSDT',name:'SUI', label:'Layer 1', highlight:'sui-xrp'},
    {symbol:'WIFUSDT',name:'WIF', label:'Meme ðŸŽ‰'},
    {symbol:'BABYUSDT',name:'BABY', label:'DeFi ðŸŸ '},
    {symbol:'ORCAUSDT',name:'ORCA', label:'DeFi ðŸŸ¡'},
    {symbol:'GUNUSDT',name:'GUN', label:'Utility ðŸ”§'},
    {symbol:'PNUTUSDT',name:'PNUT', label:'Meme ðŸ˜‚'},
    {symbol:'MOVEUSDT',name:'MOVE', label:'Layer 2 ðŸ”µ'},
    {symbol:'SHIBUSDT',name:'SHIB', label:'Meme ðŸ˜‚'},
    {symbol:'SOLUSDT',name:'SOL', label:'Layer 1 âš–ï¸'},
    {symbol:'TRUMPUSDT',name:'TRUMP', label:'Meme ðŸ˜‚'},
    {symbol:'BCHUSDT',name:'BCH', label:'Fork ðŸ´'},
    {symbol:'ENAUSDT',name:'ENA', label:'DeFi ðŸ¦'},
    {symbol:'DOGEUSDT',name:'DOGE', label:'Meme ðŸ˜‚'},
    {symbol:'ADAUSDT',name:'ADA', label:'Layer 1 âš–ï¸'},
    {symbol:'TONUSDT',name:'TON', label:'Layer 1 âš–ï¸'},
    {symbol:'AUCTIONUSDT',name:'AUCTION', label:'DeFi ðŸ¦'},
    {symbol:'ONDOUSDT',name:'ONDO', label:'DeFi ðŸ”µ'},
    {symbol:'DOTUSDT',name:'DOT', label:'Layer 1 âš–ï¸'},
    {symbol:'LINKUSDT',name:'LINK', label:'Oracle ðŸ“Š'},
    {symbol:'XLMUSDT',name:'XLM', label:'Payments ðŸ’³'},
    {symbol:'ETHUSDT',name:'ETH', label:'Layer 1 âš–ï¸'},
    {symbol:'BERAUSDT',name:'BERA', label:'Layer 1 âš–ï¸'}
  ];

  // Function to get RSI for a specific symbol and interval
  async function getRSI(sym, interval){
    // Binance API requires a limit of at least 14 for RSI calculation
    const limit = 15; // Using 15 as in the original code
    const kl = await fetch(`https://api.binance.com/api/v3/klines?symbol=${sym}&interval=${interval}&limit=${limit}`).then(r=>r.json());

    // Check if klines data is valid and has enough points
    if (!kl || kl.length < 14) {
        console.warn(`Not enough data for ${sym} on ${interval} interval.`);
        return NaN; // Return NaN if data is insufficient
    }

    let gains=0, losses=0;
    const closes = kl.map(c=>+c[4]); // Closing prices

    for(let i=1; i < closes.length; i++){
        const d = closes[i] - closes[i-1];
        if (d > 0) {
            gains += d;
        } else {
            losses -= d;
        }
    }

    // Calculate Average Gain and Average Loss
    const avgGain = gains / (closes.length - 1);
    const avgLoss = Math.abs(losses) / (closes.length - 1);

    // Calculate Relative Strength (RS)
    const rs = avgLoss === 0 ? (avgGain > 0 ? Infinity : 0) : avgGain / avgLoss;

    // Calculate Relative Strength Index (RSI)
    const rsi = 100 - (100 / (1 + rs));

    return rsi;
  }

  async function loadData(){
    // metrics
    const [g,f] = await Promise.all([
      fetch('https://api.coingecko.com/api/v3/global').then(r=>r.json()),
      fetch('https://api.alternative.me/fng/?limit=1').then(r=>r.json())
    ]);
    const mcap = g.data.total_market_cap.usd/1e9;
    const chg  = g.data.market_cap_change_percentage_24h_usd;
    const fgv  = f.data[0].value;
    const fgc  = f.data[0].value_classification;

    // Apply color to market cap percentage change
    const chgColorClass = chg >= 0 ? 'pct-green' : 'pct-red';

    document.getElementById('metrics').innerHTML =
      `Total Market Cap: $${mcap.toFixed(2)}B (<span class="${chgColorClass}">${chg.toFixed(2)}%</span>)<br>` +
      `Fear & Greed: <span style="color:${fgc.includes('Fear')?'red':'green'}">${fgv}</span> (${fgc})`;
    updateTimestamp();

    // table data
    tableData = await Promise.all(coins.map(async c => {
      const d = await fetch(`https://api.binance.com/api/v3/ticker/24hr?symbol=${c.symbol}`).then(r=>r.json());
      const pct = ((+d.lastPrice - +d.prevClosePrice) / +d.prevClosePrice) * 100;

      // Fetch only 15m RSI
      const rsi15m = await getRSI(c.symbol, '15m');

      return {
        ...c,
        low:+d.lowPrice,
        high:+d.highPrice,
        last:+d.lastPrice,
        prev:+d.prevClosePrice,
        rsi: rsi15m, // Store only 15m RSI
        pct: pct
      };
    }));
    renderTable();
  }

  // Function to generate a simple suggestion with more descriptive text
  function generateSuggestion(rsi, pctChange) {
      if (isNaN(rsi)) return 'N/A';

      if (rsi < 30) {
          // RSI is low, potentially oversold
          if (pctChange < 0) {
              return 'Coin Going Dip... (Buy Now)';
          } else {
              return 'Watch for Bounce (Potential Buy)';
          }
      } else if (rsi > 70) {
          // RSI is high, potentially overbought
          if (pctChange > 0) {
              return 'Coin Moving Up (Sell Now)';
          } else {
              return 'Watch for Dip (Potential Sell)';
          }
      } else {
          // RSI is in the middle
          if (pctChange > 5) { // Arbitrary threshold for "moving up"
              return 'Moving Up (Watch)';
          } else if (pctChange < -5) { // Arbitrary threshold for "going dip"
              return 'Going Dip (Watch)';
          } else {
              return 'Neutral (Risky)';
          }
      }
  }


  function renderTable(){
    let data = [...tableData];
    const currentInvestment = parseFloat(document.getElementById('inv').value) || 100;

    // Update table headers
    document.querySelector('th[data-key="pH"]').textContent = `$${currentInvestment.toFixed(0)} Profit Low to High`;
    document.querySelector('th[data-key="pCH"]').textContent = `$${currentInvestment.toFixed(0)} Current to High`;

    // The RSI header is now fixed to "RSI (15m)"

    if(sortKey){
      data.sort((a,b)=>{
        let va, vb;

        if (sortKey === 'coin') {
          va = a.pct;
          vb = b.pct;
        } else if (sortKey === 'type') {
           va = a.label;
           vb = b.label;
        } else if (sortKey === 'suggestion') {
            // Sort alphabetically by suggestion text
            va = generateSuggestion(a.rsi, a.pct);
            vb = generateSuggestion(b.rsi, b.pct);
            if (va < vb) return -1 * sortDir;
            if (va > vb) return 1 * sortDir;
            return 0;
        }
        else if (['low','high','last','pH','pCH'].includes(sortKey)){
           const currentInvestment = parseFloat(document.getElementById('inv').value) || 100;
           const pH_a = ((a.high - a.low)/a.low)*currentInvestment;
           const pCH_a = ((a.high - a.last)/a.last)*currentInvestment;
           const pH_b = ((b.high - b.low)/b.low)*currentInvestment;
           const pCH_b = ((b.high - b.last)/b.last)*currentInvestment;

           if (sortKey === 'pH') va = pH_a; else if (sortKey === 'pCH') va = pCH_a; else va = a[sortKey];
           if (sortKey === 'pH') vb = pH_b; else if (sortKey === 'pCH') vb = pCH_b; else vb = b[sortKey];

           va=parseFloat(va); vb=parseFloat(vb);
        } else if (sortKey === 'rsi') {
            // Get the 15m RSI values
            va = a.rsi;
            vb = b.rsi;

            // Handle potential NaN values by placing them at the end
            if (isNaN(va) && isNaN(vb)) return 0;
            if (isNaN(va)) return 1;
            if (isNaN(vb)) return -1;

            // Implement custom sorting based on rsiSortState
            if (rsiSortState === 'custom-asc') {
                // 0 to 100 then 100 to 0 (low values first, then high values ascending)
                if (va <= 50 && vb <= 50) {
                    return va - vb; // Both <= 50, sort ascending
                } else if (va > 50 && vb > 50) {
                    return va - vb; // Both > 50, sort ascending
                } else if (va <= 50 && vb > 50) {
                    return -1; // va (low) comes before vb (high)
                } else { // va > 50 && vb <= 50
                    return 1; // vb (low) comes before va (high)
                }
            } else if (rsiSortState === 'custom-desc') {
                 // 100 to 0 then 0 to 100 (high values first, then low values descending)
                 if (va > 50 && vb > 50) {
                    return vb - va; // Both > 50, sort descending
                } else if (va <= 50 && vb <= 50) {
                    return vb - va; // Both <= 50, sort descending
                } else if (va > 50 && vb <= 50) {
                    return -1; // va (high) comes before vb (low)
                } else { // va <= 50 && vb > 50
                    return 1; // vb (high) comes before va (low)
                }
            }
        }
        else {
           va = a[sortKey];
           vb = b[sortKey];
        }

        if (va > vb) return 1 * sortDir;
        if (va < vb) return -1 * sortDir;
        return 0;
      });
    }
    const tb = document.getElementById('body');
    tb.innerHTML = '';
    data.forEach(r=>{
      const pct = r.pct;
      const tr = document.createElement('tr');
      // Apply custom highlight classes
      if(r.highlight && r.highlight !== 'btc' && r.highlight !== 'top4') { // Check for new highlight classes
          tr.classList.add('highlight-' + r.highlight);
      }


      const profitLowToHigh = ((r.high - r.low)/r.low)*currentInvestment;
      const profitCurrentToHigh = ((r.high - r.last)/r.last)*currentInvestment;

      // Get the 15m RSI value
      const rsiValue = r.rsi;
      const rsiText = isNaN(rsiValue) ? 'N/A' : rsiValue.toFixed(1);
      const rsiClass = isNaN(rsiValue) ? '' : (rsiValue < 30 ? 'green' : (rsiValue > 70 ? 'red' : ''));

      // Generate suggestion and determine color class
      const suggestionText = generateSuggestion(rsiValue, pct);
      let suggestionColorClass = '';
      if (suggestionText.includes('Buy')) { // Check if suggestion includes "Buy"
          suggestionColorClass = 'buy-color';
      } else if (suggestionText.includes('Sell')) { // Check if suggestion includes "Sell"
          suggestionColorClass = 'sell-color';
      }


      tr.innerHTML =
        `<td style="text-align:left"><a href="https://www.binance.com/en/trade/${r.symbol}?type=spot" target="_blank">${r.name}</a> <span style="color:${pct<0?'red':'green'};font-size:0.8em">(${pct.toFixed(1)}%)</span></td>`+
        `<td class="rsi clickable ${rsiClass}" data-rsi-value="${rsiValue}">${rsiText}</td>`+
        `<td class="last clickable">${r.last.toFixed(precision[r.symbol])}</td>`+
        `<td class="low clickable">${r.low.toFixed(precision[r.symbol])}</td>`+
        `<td class="high clickable">${r.high.toFixed(precision[r.symbol])}</td>`+
        `<td>$${profitLowToHigh.toFixed(2)}</td>`+
        `<td>$${profitCurrentToHigh.toFixed(2)}</td>`+
        `<td class="suggestion clickable ${suggestionColorClass}">${suggestionText}</td>`+
        `<td style="text-align:left">${r.label}</td>`;
      tb.appendChild(tr);
    });

    // Add sorting listeners to headers
    document.querySelectorAll('th.sortable').forEach(th=>{
      th.onclick = ()=>{
        const key = th.dataset.key;
        if (key === 'rsi') {
            // Cycle through RSI custom sort states: 'custom-asc' -> 'custom-desc' -> 'custom-asc'
            if (rsiSortState === 'custom-asc') {
                rsiSortState = 'custom-desc';
            } else {
                rsiSortState = 'custom-asc';
            }
            sortKey = 'rsi'; // Always sort by RSI when clicking the RSI header
            sortDir = 1; // Sort direction doesn't matter as much with custom sort, but set to 1
        } else if (key === 'suggestion') {
             // Sort alphabetically by suggestion
             sortDir = (sortKey===key?-sortDir:1);
             sortKey = key;
             rsiSortState = 'custom-asc'; // Reset RSI sort state
        }
        else {
            // Existing logic for other headers
            sortDir = (sortKey===key?-sortDir:1);
            sortKey = key;
            rsiSortState = 'custom-asc'; // Reset RSI sort state when sorting by another column
        }
        renderTable();
      };
    });

    // The RSI header no longer cycles intervals, so no separate click listener needed for that.


    // feed clicks for price fields
    document.querySelectorAll('.low.clickable').forEach(c=>c.onclick=()=>{buy.value=c.textContent;updateCalc();});
    document.querySelectorAll('.high.clickable').forEach(c=>c.onclick=()=>{sell.value=c.textContent;updateCalc();}); // High price populates Sell
    document.querySelectorAll('.last.clickable').forEach(c=>c.onclick=()=>{buy.value=c.textContent;updateCalc();}); // Current price populates Buy


    // Add click listeners for RSI fields
    document.querySelectorAll('.rsi.clickable').forEach(c => {
        c.onclick = () => {
            const rsiValue = parseFloat(c.dataset.rsiValue); // Get the stored RSI value
            if (isNaN(rsiValue)) return; // Do nothing if RSI is N/A

            const row = c.closest('tr');
            const lastPriceCell = row.querySelector('.last.clickable');
            if (lastPriceCell) {
                const lastPrice = lastPriceCell.textContent;
                if (rsiValue < 30) {
                    // If RSI is low, populate the buy field with the current price
                    document.getElementById('buy').value = lastPrice;
                } else if (rsiValue > 70) {
                    // If RSI is high, populate the sell field with the current price
                    document.getElementById('sell').value = lastPrice;
                }
                updateCalc(); // Update the profit calculation
            }
        };
    });

    // Add click listeners for Suggestion fields to highlight the row
    document.querySelectorAll('.suggestion.clickable').forEach(c => {
        c.onclick = () => {
            const row = c.closest('tr');
            // Remove highlight from any previously highlighted row
            document.querySelectorAll('.highlight-suggestion').forEach(highlightedRow => {
                highlightedRow.classList.remove('highlight-suggestion');
            });
            // Add highlight to the clicked row
            row.classList.add('highlight-suggestion');
        };
    });
  }

  loadData();
  setInterval(loadData,60000); // Refresh data every 60 seconds
</script>
</body>
</html>
