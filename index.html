<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Crypto Tracker + Profit Calculator</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <style>
    /* Base styles (Light Mode) */
    body {
      font-family: 'Inter', sans-serif;
      background-color: #f0f2f5; /* Light gray background */
      color: #495057; /* Dark text color */
      transition: background-color 0.3s ease, color 0.3s ease; /* Smooth transition */
    }

    /* Dark Mode Styles */
    body.dark-mode {
      background-color: #212529; /* Dark background */
      color: #ced4da; /* Light gray text color */
    }

    /* Custom styles for specific elements (Light Mode) */
    .profit-positive { color: #0ab39c !important; /* Velzon success green */ }
    .profit-negative { color: #f06548 !important; /* Velzon danger red */ }
    .pct-green { color: #0ab39c; } /* Green for positive percentage change */
    .pct-red { color: #f06548; } /* Red for negative percentage change */
    .rsi.green { color: #0ab39c; } /* Green for low RSI */
    .rsi.red { color: #f06548; } /* Red for high RSI */

    /* Dark Mode overrides for text colors */
    body.dark-mode .profit-positive { color: #38c172 !important; /* Brighter green for dark mode */ }
    body.dark-mode .profit-negative { color: #e3342f !important; /* Brighter red for dark mode */ }
    body.dark-mode .pct-green { color: #38c172; }
    body.dark-mode .pct-red { color: #e3342f; }
    body.dark-mode .rsi.green { color: #38c172; }
    body.dark-mode .rsi.red { color: #e3342f; }


    /* Combined signal/suggestion colors (Light Mode) */
    .signal-suggestion .ma-signal.bullish { color: #0ab39c; }
    .signal-suggestion .ma-signal.bearish { color: #f06548; }
    .signal-suggestion .suggestion-text.buy-color { color: #0ab39c; }
    .suggestion-text.sell-color { color: #f06548; }

     /* Dark Mode overrides for signal/suggestion colors */
    body.dark-mode .signal-suggestion .ma-signal.bullish { color: #38c172; }
    body.dark-mode .signal-suggestion .ma-signal.bearish { color: #e3342f; }
    body.dark-mode .signal-suggestion .suggestion-text.buy-color { color: #38c172; }
    body.dark-mode .suggestion-text.sell-color { color: #e3342f; }


    /* Styles for Pressure indicators (Light Mode) */
    .pressure.buy { color: #0ab39c; } /* Green for Buy Pressure */
    .pressure.sell { color: #f06548; } /* Red for Sell Pressure */
    .pressure.neutral { color: #626c76; } /* Gray for Neutral Pressure */

     /* Dark Mode overrides for pressure colors */
    body.dark-mode .pressure.buy { color: #38c172; }
    body.dark-mode .pressure.sell { color: #e3342f; }
    body.dark-mode .pressure.neutral { color: #adb5bd; /* Lighter gray */ }


    /* Styling for the individual smaller pressure displays (Light Mode) */
    .small-pressure-display {
        padding: 0.1rem 0.3rem;
        border-radius: 0.25rem;
        background-color: #e9ecef; /* Match button background */
        color: #495057; /* Match button text color */
        font-weight: 500;
        display: inline-block;
        text-align: center;
        font-size: 0.65rem;
        white-space: nowrap;
        transition: background-color 0.3s ease, color 0.3s ease; /* Smooth transition */
    }
    /* Apply pressure colors directly to the small-pressure-display spans (Light Mode) */
    .small-pressure-display.buy { color: #0ab39c; }
    .small-pressure-display.sell { color: #f06548; }
    .small-pressure-display.neutral { color: #626c76; }

    /* Dark Mode overrides for small pressure displays */
    body.dark-mode .small-pressure-display {
        background-color: #495057; /* Darker background */
        color: #ced4da; /* Lighter text */
    }
    body.dark-mode .small-pressure-display.buy { color: #38c172; }
    body.dark-mode .small-pressure-display.sell { color: #e3342f; }
    body.dark-mode .small-pressure-display.neutral { color: #adb5bd; }


    /* Style the select dropdown arrow (Light Mode) */
    #inv, .manualCoinSelect {
        background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%2F%3E%3Cpath%20fill%3D%22%23495057%22%20d%3D%22M287%2C114.7L159.2%2C242.5c-8.8%2C8.8-23.2%2C8.8-32%2C0l-128-128c-8.8-8.8-8.8-23.2%2C0-32s23.2-8.8%2C32%2C0l112%2C112l112-112c8.8-8.8%2C23.2-8.8%2C32%2C0S295.8%2C105.9%2C287%2C114.7z%22%2F%3E%3C%2FSVG%3E');
        background-repeat: no-repeat;
        background-position: right 0.75rem top 50%;
        background-size: 0.65em auto;
        padding-right: 2.5rem;
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
    }

     /* Dark Mode override for select dropdown arrow */
    body.dark-mode #inv, body.dark-mode .manualCoinSelect {
         background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%2F%3E%3Cpath%20fill%3D%22%23ced4da%22%20d%3D%22M287%2C114.7L159.2%2C242.5c-8.8%2C8.8-23.2%2C8.8-32%2C0l-128-128c-8.8-8.8-8.8-23.2%2C0-32s23.2-8.8%2C32%2C0l112%2C112l112-112c8.8-8.8%2C23.2-8.8%2C32%2C0S295.8%2C105.9%2C287%2C114.7z%22%2F%3E%3C%2FSVG%3E'); /* Lighter arrow color */
    }


     /* Highlight for clickable suggestion row (Light Mode) */
    .highlight-suggestion { background-color: #e0e7ff !important; } /* Lighter blue highlight */

    /* Dark Mode override for suggestion highlight */
    body.dark-mode .highlight-suggestion { background-color: #495057 !important; /* Darker highlight */ }


    /* Custom highlight colors for specific coins (Light Mode) */
    .highlight-btc-red { background-color: #fee2e2 !important; } /* Light Red */
    .highlight-sui-yellow { background-color: #fef9c3 !important; } /* Light Yellow */
    .highlight-pepe-green { background-color: #dcfce7 !important; } /* Light Green */
    .highlight-sui-xrp { background-color: #e9eef4; } /* Consistent light highlight color */

    /* Dark Mode overrides for custom highlights */
    body.dark-mode .highlight-btc-red { background-color: #4a2c2c !important; /* Darker Red */ }
    body.dark-mode .highlight-sui-yellow { background-color: #4a4a2c !important; /* Darker Yellow */ }
    body.dark-mode .highlight-pepe-green { background-color: #2c4a2c !important; /* Darker Green */ }
    body.dark-mode .highlight-sui-xrp { background-color: #343a40; } /* Darker highlight */


    /* Table styles (Light Mode) */
    table {
        border-collapse: collapse;
        width: 100%;
    }
    th, td {
        padding: 0.75rem 1rem;
        border-bottom: 1px solid #e9eef4; /* Lighter border for rows */
        text-align: left;
        font-size: 0.875rem;
        vertical-align: middle;
        transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease; /* Smooth transition */
    }
    th {
        background-color: #f8f9fa; /* Light background for headers */
        font-weight: 600;
        text-transform: uppercase;
        font-size: 0.75rem;
        color: #626c76; /* Darker gray for header text */
        white-space: nowrap;
        transition: background-color 0.3s ease, color 0.3s ease; /* Smooth transition */
    }
    tbody tr:hover {
        background-color: #e9eef4; /* Hover effect on rows */
    }
    /* Apply highlight color even on hover */
    tbody tr.highlight-btc-red:hover,
    tbody tr.highlight-sui-yellow:hover,
    tbody tr.highlight-pepe-green:hover {
       /* Keep original highlight color on hover */
    }

    /* Dark Mode overrides for table styles */
    body.dark-mode th, body.dark-mode td {
        border-bottom-color: #495057; /* Darker border */
    }
    body.dark-mode th {
        background-color: #343a40; /* Darker header background */
        color: #adb5bd; /* Lighter header text */
    }
    body.dark-mode tbody tr:hover {
        background-color: #495057; /* Darker hover effect */
    }
    /* Dark Mode overrides for custom highlights on hover */
    body.dark-mode tbody tr.highlight-btc-red:hover { background-color: #4a2c2c !important; }
    body.dark-mode tbody tr.highlight-sui-yellow:hover { background-color: #4a4a2c !important; }
    body.dark-mode tbody tr.highlight-pepe-green:hover { background-color: #2c4a2c !important; }
    body.dark-mode tbody tr.highlight-sui-xrp:hover { background-color: #343a40; }


    .text-right { text-align: right; }
    .text-left { text-align: left; }
    .clickable { cursor: pointer; }

    /* Style for the main data container (card) (Light Mode) */
    .data-container {
        background-color: #ffffff; /* Card background color */
        border-radius: 0.5rem;
        box-shadow: 0 0.75rem 1.5rem rgba(18,38,63,.03); /* Velzon-like shadow */
        padding: 1.5rem;
        margin-top: 1.5rem;
        transition: background-color 0.3s ease, box-shadow 0.3s ease; /* Smooth transition */
    }

    /* Dark Mode override for data container */
    body.dark-mode .data-container {
        background-color: #343a40; /* Darker card background */
        box-shadow: 0 0.75rem 1.5rem rgba(0,0,0,.1); /* Darker shadow */
    }


    /* Style for form inputs and selects (Light Mode) */
    .input {
        border: 1px solid #ced4da; /* Light border */
        border-radius: 0.25rem;
        padding: 0.5rem 0.9rem;
        color: #495057;
        background-color: #ffffff;
        transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out, background-color 0.3s ease, color 0.3s ease; /* Smooth transition */
        font-size: 0.875rem;
    }
    .input:focus {
        border-color: #86b7fe; /* Blue focus border */
        outline: 0;
        box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, 0.25); /* Blue focus shadow */
    }
    /* Remove number input spinners */
    input[type=number]::-webkit-inner-spin-button,
    input[type=number]::-webkit-outer-spin-button { -webkit-appearance:none; margin:0; }
    input[type=number] { -moz-appearance:textfield; }

    /* Dark Mode overrides for inputs */
    body.dark-mode .input {
        border-color: #495057; /* Darker border */
        color: #ced4da; /* Lighter text */
        background-color: #495057; /* Darker background */
    }
     body.dark-mode .input:focus {
        border-color: #0d6efd; /* Brighter blue focus border */
        box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, 0.5); /* Brighter blue focus shadow */
    }
     body.dark-mode .input[disabled] {
         background-color: #6c757d; /* Darker disabled background */
         color: #adb5bd; /* Lighter disabled text */
     }


    /* Style for buttons (Light Mode) */
    .btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-weight: 500;
        line-height: 1.5;
        color: #495057;
        text-align: center;
        text-decoration: none;
        vertical-align: middle;
        cursor: pointer;
        -webkit-user-select: none;
        -moz-user-select: none;
        user-select: none;
        background-color: #e9ecef; /* Light background */
        border: 1px solid transparent;
        padding: 0.5rem 0.9rem;
        font-size: 0.875rem;
        border-radius: 0.25rem;
        transition: color 0.15s ease-in-out, background-color 0.15s ease-in-out, border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
    }
    .btn:hover {
        color: #495057;
        background-color: #d3d9df;
        border-color: #c6cd D2;
    }
    .btn-sm {
        padding: 0.1rem 0.3rem;
        font-size: 0.75rem;
    }
    .btn-rsi, .btn-page {
        background-color: #e9ecef;
        color: #495057;
        border: 1px solid #ced4da;
    }
    .btn-rsi.active, .btn-page.active {
        background-color: #0ab39c; /* Use success green */
        color: #ffffff;
        border-color: #0ab39c;
    }

    /* Dark Mode overrides for buttons */
    body.dark-mode .btn {
        color: #ced4da; /* Lighter text */
        background-color: #495057; /* Darker background */
        border-color: #6c757d; /* Darker border */
    }
    body.dark-mode .btn:hover {
        color: #ffffff; /* White text on hover */
        background-color: #6c757d; /* Even darker background on hover */
        border-color: #adb5bd; /* Lighter border on hover */
    }
     body.dark-mode .btn-rsi, body.dark-mode .btn-page {
        background-color: #495057;
        color: #ced4da;
        border: 1px solid #6c757d;
    }
    body.dark-mode .btn-rsi.active, body.dark-mode .btn-page.active {
        background-color: #38c172; /* Brighter green */
        color: #ffffff;
        border-color: #38c172;
    }


    /* Style for the combined control button container */
    .button-controls-container {
        display: flex;
        flex-wrap: wrap;
        justify-content: space-between;
        align-items: center;
        gap: 1rem;
        margin-bottom: 1rem;
    }
    .rsi-buttons, .page-buttons {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        align-items: center;
    }
     /* Container for the three small pressure displays */
    .pressure-displays-small {
        display: flex;
        gap: 0.5rem;
        align-items: center;
        flex-wrap: wrap;
    }


     /* Specific styles for buy/sell inputs (Light Mode) */
    .buy {
        background-color: #eaf6f5; /* Light greenish */
        border-color: #d3edea;
        color: #0ab39c;
    }
     .sell {
        background-color: #fef0ee; /* Light reddish */
        border-color: #fcd9d2;
        color: #f06548;
    }

    /* Dark Mode overrides for buy/sell inputs */
    body.dark-mode .buy {
        background-color: #2c4a2c; /* Darker greenish */
        border-color: #38c172;
        color: #38c172;
    }
     body.dark-mode .sell {
        background-color: #4a2c2c; /* Darker reddish */
        border-color: #e3342f;
        color: #e3342f;
    }


    /* Specific style for profit display (Light Mode) */
    .profit {
        font-weight: 700;
        padding: 0.75rem 1.25rem !important;
        font-size: 1.125rem !important;
        border-width: 2px;
        border-style: solid;
        transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease; /* Smooth transition */
    }
    /* Enhance positive/negative profit styles (Light Mode) */
     .profit-positive-bg {
        color: #087a6a; /* Darker Success Green */
        background-color: #d1fdee; /* Lighter Success Green background */
        border-color: #a3e9dd; /* Success Green border */
     }
     .profit-negative-bg {
         color: #d6472c; /* Darker Danger Red */
         background-color: #fde8e4; /* Lighter Danger Red background */
         border-color: #fcc5ba; /* Danger Red border */
     }

    /* Dark Mode overrides for profit display */
    body.dark-mode .profit {
         /* No specific overrides needed for base profit style, colors handled by profit-positive/negative-bg */
    }
     body.dark-mode .profit-positive-bg {
        color: #38c172; /* Brighter Success Green */
        background-color: #2c4a2c; /* Darker Success Green background */
        border-color: #38c172; /* Brighter Success Green border */
     }
     body.dark-mode .profit-negative-bg {
         color: #e3342f; /* Brighter Danger Red */
         background-color: #4a2c2c; /* Darker Danger Red background */
         border-color: #e3342f; /* Brighter Danger Red border */
     }


    /* Style for the smaller suggestion text within the merged cell (Light Mode) */
    .suggestion-text {
        font-size: 0.75rem;
        color: #6b7280; /* gray-500 */
        display: block;
        margin-top: 0.1rem;
        transition: color 0.3s ease; /* Smooth transition */
    }
    /* Apply specific suggestion colors to the smaller text (Light Mode) */
    .suggestion-text.buy-color { color: #0ab39c !important; }
    .suggestion-text.sell-color { color: #f06548 !important; }

    /* Dark Mode overrides for suggestion text */
    body.dark-mode .suggestion-text {
        color: #adb5bd; /* Lighter gray */
    }
    body.dark-mode .suggestion-text.buy-color { color: #38c172 !important; }
    body.dark-mode .suggestion-text.sell-color { color: #e3342f !important; }


    /* Style for smaller font in table cells (for ATH/ATL) */
    .text-xxs {
        font-size: 0.65rem;
    }

    /* Manual Profit Calculator Section Styles (Light Mode) */
    .manual-calc-row {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 0.75rem;
        padding: 1rem;
        background-color: #ffffff; /* White background for each row */
        border-radius: 0.5rem;
        box-shadow: 0 0.75rem 1.5rem rgba(18,38,63,.03);
        border: 1px solid #e9eef4;
        margin-bottom: 0.5rem;
        transition: background-color 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease; /* Smooth transition */
    }

    /* Dark Mode overrides for manual calc rows */
    body.dark-mode .manual-calc-row {
        background-color: #343a40; /* Darker background */
        box-shadow: 0 0.75rem 1.5rem rgba(0,0,0,.1);
        border-color: #495057; /* Darker border */
    }


    /* Hide the container for calculators 3, 4, 5 by default */
    #hiddenManualCalcs {
        display: none;
        flex-direction: column; /* Ensure it stacks vertically when shown */
        gap: 0.5rem; /* Add gap between rows when shown */
    }

    .manual-calc-row > div {
        display: flex;
        align-items: center;
        gap: 0.25rem;
    }

    .manual-calc-row label {
        font-size: 0.75rem;
        color: #626c76;
        white-space: nowrap;
        transition: color 0.3s ease; /* Smooth transition */
    }

     /* Dark Mode override for manual calc labels */
    body.dark-mode .manual-calc-row label {
        color: #adb5bd; /* Lighter gray */
    }


    .manual-calc-row .input {
        padding: 0.3rem 0.6rem;
        font-size: 0.75rem;
        width: 80px;
        text-align: right;
    }

     .manual-calc-row select.input {
        width: 100px;
     }

    .manual-profit-display {
        font-weight: 700;
        padding: 0.5rem 0.9rem !important;
        font-size: 0.875rem !important;
        border-width: 1px;
        border-style: solid;
        text-align: center;
        flex-grow: 1;
        min-width: 120px;
        transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease; /* Smooth transition */
    }
    /* Manual profit display colors handled by profit-positive/negative */


    /* Compact Main Calculator Styles (Light Mode) */
    .compact-calc-row {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 0.75rem;
    }

    .compact-calc-row > div {
        display: flex;
        align-items: center;
        gap: 0.25rem;
    }

     .compact-calc-row label {
        font-size: 0.75rem;
        color: #626c76;
        white-space: nowrap;
        transition: color 0.3s ease; /* Smooth transition */
     }

     /* Dark Mode override for compact calc labels */
     body.dark-mode .compact-calc-row label {
         color: #adb5bd; /* Lighter gray */
     }


     .compact-calc-row .input {
        padding: 0.3rem 0.6rem;
        font-size: 0.75rem;
        width: 80px;
        text-align: right;
     }

     .compact-calc-row select.input {
         width: 100px;
     }

     .compact-profit-display {
        font-weight: 700;
        padding: 0.5rem 0.9rem !important;
        font-size: 0.875rem !important;
        border-width: 1px;
        border-style: solid;
        text-align: center;
        flex-grow: 1;
        min-width: 120px;
        transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease; /* Smooth transition */
     }
     /* Compact profit display colors handled by profit-positive/negative-bg */


    /* Style for inline profit display in the table (Light Mode) */
    .manual-profit-inline {
        font-weight: 500;
        font-size: 0.875rem;
        transition: color 0.3s ease; /* Smooth transition */
    }
    /* Ensure profit colors apply (Light Mode) */
    .manual-profit-inline.profit-positive { color: #0ab39c !important; }
    .manual-profit-inline.profit-negative { color: #f06548 !important; }

    /* Dark Mode overrides for inline profit display */
    body.dark-mode .manual-profit-inline.profit-positive { color: #38c172 !important; }
    body.dark-mode .manual-profit-inline.profit-negative { color: #e3342f !important; }


    /* Styles for Add/Remove Coin Controls (Light Mode) */
    .coin-management-controls {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        flex-wrap: wrap;
        font-size: 0.75rem;
    }

    .coin-management-controls .input {
        font-size: 0.75rem;
        padding: 0.1rem 0.3rem;
        width: 80px;
    }

    .coin-management-controls .btn-sm {
        font-size: 0.75rem;
        padding: 0.1rem 0.3rem;
    }

    .btn-add-coin {
        background-color: #d1fdee; /* Light green */
        color: #087a6a; /* Darker green text */
        border-color: #a3e9dd; /* Green border */
    }
    .btn-add-coin:hover {
        background-color: #a3e9dd; /* Darker green on hover */
        border-color: #087a6a;
    }

    .btn-remove-coin {
        background-color: #fde8e4; /* Light red */
        color: #d6472c; /* Darker red text */
        border-color: #fcc5ba; /* Red border */
    }
    .btn-remove-coin:hover {
        background-color: #fcc5ba; /* Darker red on hover */
        border-color: #d6472c;
    }

     .btn-reset-coins {
         background-color: #e9ecef; /* Light gray */
         color: #495057; /* Default text */
         border-color: #ced4da; /* Default border */
     }
     .btn-reset-coins:hover {
         background-color: #d3d9df;
         border-color: #c6cd D2;
     }

     /* Dark Mode overrides for coin management buttons */
     body.dark-mode .btn-add-coin {
        background-color: #2c4a2c; /* Darker green */
        color: #38c172; /* Brighter green text */
        border-color: #38c172; /* Brighter green border */
    }
    body.dark-mode .btn-add-coin:hover {
        background-color: #38c172; /* Brighter green on hover */
        border-color: #2c4a2c;
    }

    body.dark-mode .btn-remove-coin {
        background-color: #4a2c2c; /* Darker red */
        color: #e3342f; /* Brighter red text */
        border-color: #e3342f; /* Brighter red border */
    }
    body.dark-mode .btn-remove-coin:hover {
        background-color: #e3342f; /* Brighter red on hover */
        border-color: #4a2c2c;
    }

     body.dark-mode .btn-reset-coins {
         background-color: #495057; /* Darker gray */
         color: #ced4da; /* Lighter text */
         border-color: #6c757d; /* Darker border */
     }
     body.dark-mode .btn-reset-coins:hover {
         background-color: #6c757d;
         border-color: #adb5bd;
     }


     /* Combined container for refresh info and coin management */
     .refresh-and-coin-controls {
         display: flex;
         flex-wrap: wrap;
         justify-content: space-between;
         align-items: center;
         gap: 1rem;
         margin-bottom: 1rem;
     }

    /* Style for the toggle top coin button/icon (Light Mode) */
    .toggle-top-coin {
        cursor: pointer;
        margin-left: 0.5rem;
        font-size: 0.85rem;
        color: #ced4da; /* Default gray color */
        transition: color 0.15s ease-in-out;
    }
    .toggle-top-coin:hover {
        color: #626c76; /* Darker gray on hover */
    }
    /* Star color to green */
    .toggle-top-coin.is-top-coin {
        color: #0ab39c; /* Green color for starred coins */
    }
    .toggle-top-coin.is-top-coin:hover {
        color: #087a6a; /* Darker green on hover */
    }

     /* Dark Mode overrides for toggle top coin icon */
    body.dark-mode .toggle-top-coin {
        color: #6c757d; /* Darker gray */
    }
    body.dark-mode .toggle-top-coin:hover {
        color: #adb5bd; /* Lighter gray on hover */
    }
    body.dark-mode .toggle-top-coin.is-top-coin {
        color: #38c172; /* Brighter green */
    }
    body.dark-mode .toggle-top-coin.is-top-coin:hover {
        color: #2c8b5a; /* Even brighter green on hover */
    }


    /* Dark Mode Toggle Button Styles */
    #darkModeToggle {
        background-color: #e9ecef; /* Light background */
        color: #495057; /* Dark text */
        border: 1px solid #ced4da; /* Light border */
        padding: 0.25rem 0.5rem;
        border-radius: 0.25rem;
        cursor: pointer;
        font-size: 0.875rem;
        transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease; /* Smooth transition */
    }
    #darkModeToggle:hover {
        background-color: #d3d9df;
        border-color: #c6cd D2;
    }

    /* Dark Mode override for the toggle button */
    body.dark-mode #darkModeToggle {
        background-color: #495057; /* Darker background */
        color: #ced4da; /* Lighter text */
        border-color: #6c757d; /* Darker border */
    }
    body.dark-mode #darkModeToggle:hover {
        background-color: #6c757d;
        border-color: #adb5bd;
    }


    /* Responsive adjustments */
    @media (max-width: 768px) {
        .calc-row > div {
            width: 100%;
            margin-bottom: 0.5rem;
        }
        .calc-row > div:last-child { margin-bottom: 0; }
        .button-controls-container { flex-direction: column; align-items: flex-start; gap: 0.75rem; }
        .rsi-buttons, .page-buttons { justify-content: flex-start; }
        th, td { padding: 0.5rem; font-size: 0.8rem; }
        th { font-size: 0.65rem; }
        .profit { font-size: 1rem !important; padding: 0.6rem 1rem !important; }
        .pressure-displays-small { min-width: auto; width: 100%; justify-content: flex-start; }
        .small-pressure-display { flex-grow: 0; }

        .manual-calc-row {
             flex-direction: column;
             align-items: flex-start;
             gap: 0.5rem;
        }
         .manual-calc-row > div {
             width: 100%;
             justify-content: space-between;
         }
         .manual-calc-row .input {
             width: auto;
             flex-grow: 1;
         }
          .manual-calc-row select.input {
             width: auto;
             flex-grow: 1;
         }
         .manual-profit-display {
             width: 100%;
         }

         .compact-calc-row {
             flex-direction: column;
             align-items: flex-start;
             gap: 0.5rem;
         }
          .compact-calc-row > div {
             width: 100%;
             justify-content: space-between;
         }
         .compact-calc-row .input {
             width: auto;
             flex-grow: 1;
         }
          .compact-calc-row select.input {
             width: auto;
             flex-grow: 1;
         }
         .compact-profit-display {
             width: 100%;
         }
         .manual-profit-inline {
            display: block;
            margin-left: 0;
            margin-top: 0.2rem;
         }

         .refresh-and-coin-controls {
             flex-direction: column;
             align-items: flex-start;
             gap: 0.75rem;
         }
         .refresh-info, .coin-management-controls {
             width: 100%;
             justify-content: space-between;
         }
         .coin-management-controls input {
             width: auto;
             flex-grow: 1;
         }
         .coin-management-controls button {
             width: auto;
         }
         /* Adjust dark mode toggle position on mobile */
         #darkModeToggle {
             margin-top: 0.5rem; /* Add space above toggle */
             align-self: flex-start; /* Align left */
         }
    }
  </style>
</head>
<body class="p-4 md:p-8">
  <div class="max-w-7xl mx-auto">
    <div class="flex justify-between items-center mb-1">
        <div id="clock" class="font-bold text-blue-600 text-lg md:text-xl">BD Time: --:--:--</div>
        <button id="darkModeToggle">Toggle Dark Mode</button>
    </div>
    <div id="timestamp" class="text-xs md:text-sm text-gray-600 mb-2">Loading...</div>
    <div id="metrics" class="text-xs md:text-sm text-gray-600 mb-4"></div>
    <div id="error" class="text-sm text-red-600 mb-4"></div>


    <div class="data-container">
      <div class="compact-calc-row mb-6">
        <div class="flex items-center gap-1">
           <label for="fee" class="text-gray-600 text-xs md:text-sm mr-1">Fee%:</label>
           <button class="btn btn-sm" onclick="step('fee',-1)">–</button>
           <input id="fee" class="input text-right w-16" type="number" value="0.15" step="0.001" oninput="updateCalc(); updateAllManualCalcs();"/>
           <button class="btn btn-sm" onclick="step('fee',1)">+</button>
        </div>
        <div class="flex items-center gap-1">
           <label for="inv" class="text-gray-600 text-xs md:text-sm mr-1">Invest:</label>
           <select id="inv" class="input text-right w-24 appearance-none" onchange="updateCalc(); renderTable();">
              <option value="25">25</option>
              <option value="50">50</option>
              <option value="100">100</option>
              <option value="200">200</option>
              <option value="300">300</option>
              <option value="400">400</option>
              <option value="500">500</option>
              <option value="600">600</option>
              <option value="700">700</option>
              <option value="800">800</option>
              <option value="900">900</option>
              <option value="1000" selected>1000</option>
              <option value="1111">1111</option>
              <option value="1222">1222</option>
              <option value="1333">1333</option>
              <option value="1444">1444</option>
              <option value="1500">1500</option>
              <option value="2000">2000</option>
              <option value="3000">3000</option>
              <option value="4000">4000</option>
              <option value="5000">5000</option>
              <option value="10000">10000</option>
           </select>
        </div>
        <div class="flex items-center gap-1 flex-grow min-w-[150px]">
           <label for="buy" class="text-gray-600 text-xs md:text-sm mr-1">Buy:</label>
           <button class="btn btn-sm" onclick="step('buy',-1)">–</button>
           <input id="buy" class="input buy text-right flex-grow" type="number" step="any" placeholder="Buy Price" oninput="updateCalc()"/>
           <button class="btn btn-sm" onclick="step('buy',1)">+</button>
        </div>
        <div class="flex items-center gap-1 flex-grow min-w-[150px]">
            <label for="sell" class="text-gray-600 text-xs md:text-sm mr-1">Sell:</label>
           <button class="btn btn-sm" onclick="step('sell',-1)">–</button>
           <input id="sell" class="input sell text-right flex-grow" type="number" step="any" placeholder="Sell Price" oninput="updateCalc()"/>
           <button class="btn btn-sm" onclick="step('sell',1)">+</button>
         </div>
         <div id="profit" class="input compact-profit-display text-center flex-grow min-w-[150px] md:min-w-[180px]">0.00 USDT</div>
       </div>

       <div class="button-controls-container">
           <div class="rsi-buttons">
              <span class="text-sm font-medium self-center">RSI:</span>
              <button class="btn btn-sm btn-rsi" data-interval="1m" onclick="selectRsiInterval(this)">1m</button>
              <button class="btn btn-sm btn-rsi" data-interval="3m" onclick="selectRsiInterval(this)">3m</button>
              <button class="btn btn-sm btn-rsi" data-interval="5m" onclick="selectRsiInterval(this)">5m</button>
              <button class="btn btn-sm btn-rsi active" data-interval="15m" onclick="selectRsiInterval(this)">15m</button>
              <button class="btn btn-sm btn-rsi" data-interval="30m" onclick="selectRsiInterval(this)">30m</button>
              <button class="btn btn-sm btn-rsi" data-interval="1h" onclick="selectRsiInterval(this)">1h</button>
              <button class="btn btn-sm btn-rsi" data-interval="6h" onclick="selectRsiInterval(this)">6h</button>
              <button class="btn btn-sm btn-rsi" data-interval="12h" onclick="selectRsiInterval(this)">12h</button>
              <button class="btn btn-sm btn-rsi" data-interval="24h" onclick="selectRsiInterval(this)">24h</button>
          </div>
          <div class="page-buttons">
              <span class="text-sm font-medium self-center">View:</span>
              <button class="btn btn-sm btn-page active" data-page="top4" onclick="selectPage(this)">Top Coins</button>
              <button class="btn btn-sm btn-page" data-page="all" onclick="selectPage(this)">All Coins</button>
          </div>
          <div class="pressure-displays-small">
              <div id="btc-pressure-small" class="small-pressure-display neutral">Loading...</div>
              <div id="sui-pressure-small" class="small-pressure-display neutral">Loading...</div>
              <div id="pepe-pressure-small" class="small-pressure-display neutral">Loading...</div>
          </div>
           <div class="refresh-and-coin-controls">
               <div class="refresh-info flex items-center gap-2">
                   <span id="refresh-interval-display" class="text-sm font-medium self-center text-gray-600">Auto Refresh: 5s</span>
                   <span id="rate-limit-warning" class="text-xs text-amber-600 hidden">High frequency may cause rate limits.</span>
                   <button id="refresh-on-btn" class="btn btn-sm" onclick="startAutoRefresh()">Refresh ON</button>
                   <button id="refresh-off-btn" class="btn btn-sm" onclick="stopAutoRefresh()">Refresh OFF</button>
                   <button id="manual-refresh-btn" class="btn btn-sm" onclick="manualRefresh()">Manual Refresh</button>
                </div>
                <div class="coin-management-controls">
                    <input id="coinSymbolInput" class="input text-xs md:text-sm" type="text" placeholder="Symbol"/>
                    <button id="addCoinBtn" class="btn btn-sm btn-add-coin">Add</button>
                    <button id="removeCoinBtn" class="btn btn-sm btn-remove-coin">Remove</button>
                    </div>
            </div>
      </div>

      <div class="overflow-x-auto mt-4">
        <table class="min-w-full">
          <thead>
            <tr>
              <th class="sortable text-left" data-key="coin">Coin (% Change) [Calc Profit]</th>
              <th class="sortable clickable text-right" data-key="rsi" id="rsiHeader">RSI (15m)</th>
              <th class="sortable text-right" data-key="last">Current</th>
              <th class="sortable text-right" data-key="low">24h Low</th>
              <th class="sortable text-right" data-key="high">24h High</th>
              <th class="sortable text-right" data-key="pH" id="profitLowHighHeader">$1000 L→H</th>
              <th class="sortable text-right" data-key="pCH" id="profitCurrentHighHeader">$1000 C→H</th>
              <th class="sortable text-right" data-key="volume">24h Vol</th>
              <th class="sortable clickable text-left" data-key="signalSuggestion">Signal / Suggestion</th>
            </tr>
          </thead>
          <tbody id="body">
            </tbody>
        </table>
      </div>
    </div>
    <div class="flex flex-col gap-2 mt-6 max-w-7xl mx-auto">
       <div class="manual-calc-row">
          <div class="flex items-center gap-1 flex-grow justify-end">
              <label class="text-gray-600 text-sm font-semibold">Total Manual Profit:</label>
          </div>
          <div id="manualTotalProfit" class="manual-profit-display font-bold text-center flex-grow min-w-[150px] md:min-w-[180px]">0.00 USDT</div>
      </div>

       <div class="manual-calc-row" data-calc-index="1">
         <div>
           <select id="manualCoinSelect1" class="input manualCoinSelect appearance-none" onchange="updateManualCalc(1); saveManualCalcData(1);"></select>
         </div>
         <div>
           <label for="manualAmount1">Coin Qty:</label> <input id="manualAmount1" class="input text-right" type="number" step="any" value="" placeholder="0" oninput="updateManualCalc(1); saveManualCalcData(1);"/>
         </div>
         <div>
           <label for="manualInvest1">USDT Cost:</label> <input id="manualInvest1" class="input text-right" type="number" step="any" value="" placeholder="0" oninput="updateManualCalc(1); saveManualCalcData(1)"/>
         </div>
         <div>
           <label for="manualBuyPrice1">Buy Price:</label>
           <input id="manualBuyPrice1" class="input text-right" type="number" step="any" value="" placeholder="0" oninput="updateManualCalc(1); saveManualCalcData(1)"/>
         </div>
         <div>
           <label>Current:</label>
           <span id="manualCurrentPrice1" class="input text-right bg-gray-100 text-gray-700">N/A</span>
         </div>
         <div id="manualProfit1" class="manual-profit-display">0.00 USDT</div>
       </div>

       <div class="manual-calc-row" data-calc-index="2">
        <div>
          <select id="manualCoinSelect2" class="input manualCoinSelect appearance-none" onchange="updateManualCalc(2); saveManualCalcData(2);"></select>
        </div>
        <div>
          <label for="manualAmount2">Coin Qty:</label> <input id="manualAmount2" class="input text-right" type="number" step="any" value="" placeholder="0" oninput="updateManualCalc(2); saveManualCalcData(2)"/>
        </div>
        <div>
          <label for="manualInvest2">USDT Cost:</label> <input id="manualInvest2" class="input text-right" type="number" step="any" value="" placeholder="0" oninput="updateManualCalc(2); saveManualCalcData(2)"/>
        </div>
        <div>
          <label for="manualBuyPrice2">Buy Price:</label>
          <input id="manualBuyPrice2" class="input text-right" type="number" step="any" value="" placeholder="0" oninput="updateManualCalc(2); saveManualCalcData(2)"/>
        </div>
        <div>
          <label>Current:</label>
          <span id="manualCurrentPrice2" class="input text-right bg-gray-100 text-gray-700">N/A</span>
        </div>
        <div id="manualProfit2" class="manual-profit-display">0.00 USDT</div>
      </div>

      <button id="showMoreCalcsBtn" class="btn mt-2 mb-4 mx-auto" onclick="toggleHiddenCalcs()">Show More Calculators</button>

      <div id="hiddenManualCalcs">
          <div class="manual-calc-row" data-calc-index="3">
            <div>
              <select id="manualCoinSelect3" class="input manualCoinSelect appearance-none" onchange="updateManualCalc(3); saveManualCalcData(3);"></select>
            </div>
            <div>
              <label for="manualAmount3">Coin Qty:</label> <input id="manualAmount3" class="input text-right" type="number" step="any" value="" placeholder="0" oninput="updateManualCalc(3); saveManualCalcData(3)"/>
            </div>
            <div>
              <label for="manualInvest3">USDT Cost:</label> <input id="manualInvest3" class="input text-right" type="number" step="any" value="" placeholder="0" oninput="updateManualCalc(3); saveManualCalcData(3)"/>
            </div>
            <div>
              <label for="manualBuyPrice3">Buy Price:</label>
              <input id="manualBuyPrice3" class="input text-right" type="number" step="any" value="" placeholder="0" oninput="updateManualCalc(3); saveManualCalcData(3)"/>
            </div>
            <div>
              <label>Current:</label>
              <span id="manualCurrentPrice3" class="input text-right bg-gray-100 text-gray-700">N/A</span>
            </div>
            <div id="manualProfit3" class="manual-profit-display">0.00 USDT</div>
          </div>

          <div class="manual-calc-row" data-calc-index="4">
            <div>
              <select id="manualCoinSelect4" class="input manualCoinSelect appearance-none" onchange="updateManualCalc(4); saveManualCalcData(4);"></select>
            </div>
            <div>
              <label for="manualAmount4">Coin Qty:</label> <input id="manualAmount4" class="input text-right" type="number" step="any" value="" placeholder="0" oninput="updateManualCalc(4); saveManualCalcData(4)"/>
            </div>
            <div>
              <label for="manualInvest4">USDT Cost:</label> <input id="manualInvest4" class="input text-right" type="number" step="any" value="" placeholder="0" oninput="updateManualCalc(4); saveManualCalcData(4)"/>
            </div>
            <div>
              <label for="manualBuyPrice4">Buy Price:</label>
              <input id="manualBuyPrice4" class="input text-right" type="number" step="any" value="" placeholder="0" oninput="updateManualCalc(4); saveManualCalcData(4)"/>
            </div>
            <div>
              <label>Current:</label>
              <span id="manualCurrentPrice4" class="input text-right bg-gray-100 text-gray-700">N/A</span>
            </div>
            <div id="manualProfit4" class="manual-profit-display">0.00 USDT</div>
          </div>

          <div class="manual-calc-row" data-calc-index="5">
            <div>
              <select id="manualCoinSelect5" class="input manualCoinSelect appearance-none" onchange="updateManualCalc(5); saveManualCalcData(5);"></select>
            </div>
            <div>
              <label for="manualAmount5">Coin Qty:</label> <input id="manualAmount5" class="input text-right" type="number" step="any" value="" placeholder="0" oninput="updateManualCalc(5); saveManualCalcData(5)"/>
            </div>
            <div>
              <label for="manualInvest5">USDT Cost:</label> <input id="manualInvest5" class="input text-right" type="number" step="any" value="" placeholder="0" oninput="updateManualCalc(5); saveManualCalcData(5)"/>
            </div>
            <div>
              <label for="manualBuyPrice5">Buy Price:</label>
              <input id="manualBuyPrice5" class="input text-right" type="number" step="any" value="" placeholder="0" oninput="updateManualCalc(5); saveManualCalcData(5)"/>
            </div>
            <div>
              <label>Current:</label>
              <span id="manualCurrentPrice5" class="input text-right bg-gray-100 text-gray-700">N/A</span>
            </div>
            <div id="manualProfit5" class="manual-profit-display">0.00 USDT</div>
          </div>
      </div> </div>
    <div class="mt-6 text-center text-sm text-gray-600 max-w-7xl mx-auto"> Disclaimer: The Pressure indicators are based on Binance Order Book Depth data and are not definitive trading signals. Order book data changes rapidly. This tool is for informational purposes only and not financial advice. Trading involves risk.
    </div>
  </div>
  <script>
  // --- Global Variables ---
  let sortKey = 'volume'; // Default sort key
  let sortDir = -1; // Default sort direction (descending for volume)
  let rsiSortState = 'custom-asc'; // For RSI custom sort logic
  let allTableData = []; // Holds data for ALL coins fetched
  const rsiIntervals = ['1m', '3m', '5m', '15m', '30m', '1h', '6h', '12h', '24h'];
  let currentRsiInterval = '15m';
  let currentPage = 'top4'; // 'top4' or 'all'
  let dataRefreshTimeoutId;
  let globalMetricsIntervalId; // New interval ID for global metrics
  let isAutoRefreshEnabled = true; // Flag to control auto-refresh
  let isDarkMode = false; // State for dark mode

  // Define refresh intervals for each page and global metrics
  const REFRESH_INTERVAL_TOP4_MS = 5000; // 5 seconds
  const REFRESH_INTERVAL_ALL_MS = 900000; // 15 minutes
  const REFRESH_INTERVAL_GLOBAL_MS = 900000; // 15 minutes

  // Define default coin lists
  const defaultCoins = [
    {symbol:'BTCUSDT',name:'BTC', label:'Layer 1', highlight:'btc-red'},
    {symbol:'SUIUSDT',name:'SUI', label:'Layer 1', highlight:'sui-yellow'},
    {symbol:'XRPUSDT',name:'XRP', label:'Payments 💳'},
    {symbol:'PEPEUSDT',name:'PEPE', label:'Meme 😂', highlight:'pepe-green'},
    {symbol:'TRUMPUSDT',name:'TRUMP', label:'Meme 😂'},
    {symbol:'WIFUSDT',name:'WIF', label:'Meme 🎉'},
    {symbol:'BABYUSDT',name:'BABY', label:'DeFi 🟠'},
    {symbol:'ORCAUSDT',name:'ORCA', label:'DeFi 🟡'},
    {symbol:'GUNUSDT',name:'GUN', label:'Utility 🔧'},
    {symbol:'PNUTUSDT',name:'PNUT', label:'Meme 😂'},
    {symbol:'MOVEUSDT',name:'MOVE', label:'Layer 2 🔵'},
    {symbol:'SHIBUSDT',name:'SHIB', label:'Meme 😂'},
    {symbol:'SOLUSDT',name:'SOL', label:'Layer 1 ⚖️'},
    {symbol:'BCHUSDT',name:'BCH', label:'Fork 🍴'},
    {symbol:'ENAUSDT',name:'ENA', label:'DeFi 🏦'},
    {symbol:'DOGEUSDT',name:'DOGE', label:'Meme 😂'},
    {symbol:'ADAUSDT',name:'ADA', label:'Layer 1 ⚖️'},
    {symbol:'TONUSDT',name:'TON', label:'Layer 1 ⚖️'},
    {symbol:'AUCTIONUSDT',name:'AUCTION', label:'DeFi 🏦'},
    {symbol:'ONDOUSDT',name:'ONDO', label:'DeFi 🔵'},
    {symbol:'DOTUSDT',name:'DOT', label:'Layer 1 ⚖️'},
    {symbol:'LINKUSDT',name:'LINK', label:'Oracle 📊'},
    {symbol:'XLMUSDT',name:'XLM', label:'Payments 💳'},
    {symbol:'ETHUSDT',name:'ETH', label:'Layer 1 ⚖️'},
    {symbol:'BERAUSDT',name:'BERA', label:'Layer 1 ⚖️'}
  ];

  // TOP_COINS is now a mutable array loaded from storage
  let topCoins = ['BTCUSDT', 'SUIUSDT', 'XRPUSDT', 'PEPEUSDT', 'TRUMPUSDT']; // Default Top Coins

  // Current active coin list (initially defaults, loaded from storage later)
  let coins = [];

  // Pressure display variables
  const pressureCoins = ['BTCUSDT', 'SUIUSDT', 'PEPEUSDT'];
  let pressureData = {}; // Store pressure data for these coins


  // --- Coin Definitions and Mappings ---
  // This map is now primarily for fetching CoinGecko data, not the main coin list
  const coinGeckoIdMap = {
      'BTCUSDT': 'bitcoin', 'ETHUSDT': 'ethereum', 'XRPUSDT': 'ripple', 'SUIUSDT': 'sui',
      'WIFUSDT': 'dogwifcoin', 'PEPEUSDT': 'pepe', 'SHIBUSDT': 'shiba-inu', 'SOLUSDT': 'solana',
      'DOGEUSDT': 'dogecoin', 'ADAUSDT': 'cardano', 'TONUSDT': 'toncoin', 'DOTUSDT': 'polkadot',
      'LINKUSDT': 'chainlink', 'BCHUSDT': 'bitcoin-cash', 'XLMUSDT': 'stellar', 'ENAUSDT': 'ena',
      'ONDOUSDT': 'ondo',
      // Add more mappings as needed
  };

  // Precision mapping for formatting prices (can be extended for new coins)
  const precision = {BTCUSDT:2,ETHUSDT:2,TRUMPUSDT:4,DOTUSDT:2,SOLUSDT:2,AUCTIONUSDT:2,LINKUSDT:2,BCHUSDT:2,PNUTUSDT:5,SUIUSDT:4,XRPUSDT:4,GUNUSDT:3,BABYUSDT:3,ONDOUSDT:4,DOGEUSDT:5,XLMUSDT:4,ADAUSDT:4,TONUSDT:2,ORCAUSDT:2,BERAUSDT:2,ENAUSDT:4,PEPEUSDT:8,SHIBUSDT:8,WIFUSDT:4,MOVEUSDT:4};


  // --- Local Storage Functions ---
  function saveCoins() {
      try {
          localStorage.setItem('cryptoTrackerCoins', JSON.stringify(coins));
          localStorage.setItem('cryptoTrackerTopCoins', JSON.stringify(topCoins)); // Save top coins
          // console.log('Coins and Top Coins saved to localStorage.');
      } catch (e) {
          console.error('Failed to save coins to localStorage:', e);
          updateErrorDisplay('Failed to save coin list. Browser storage might be full or disabled.');
      }
  }

  function loadCoins() {
      try {
          const savedCoins = localStorage.getItem('cryptoTrackerCoins');
          const savedTopCoins = localStorage.getItem('cryptoTrackerTopCoins'); // Load top coins

          if (savedCoins) {
              const parsedCoins = JSON.parse(savedCoins);
              if (Array.isArray(parsedCoins) && parsedCoins.every(c => c.symbol && c.name)) {
                   coins = parsedCoins;
                   console.log('Coins loaded from localStorage.');
              } else {
                  console.warn('Invalid coins data in localStorage. Using default coins.');
                  coins = [...defaultCoins];
              }
          } else {
              console.log('No coins found in localStorage. Using default coins.');
              coins = [...defaultCoins];
          }

          if (savedTopCoins) {
               const parsedTopCoins = JSON.parse(savedTopCoins);
               if (Array.isArray(parsedTopCoins)) { // Simple check for top coins array
                   topCoins = parsedTopCoins;
                   console.log('Top Coins loaded from localStorage.');
               } else {
                   console.warn('Invalid top coins data in localStorage. Using default top coins.');
                   topCoins = ['BTCUSDT', 'SUIUSDT', 'XRPUSDT', 'PEPEUSDT', 'TRUMPUSDT']; // Default top coins
               }
          } else {
              console.log('No top coins found in localStorage. Using default top coins.');
              topCoins = ['BTCUSDT', 'SUIUSDT', 'XRPUSDT', 'PEPEUSDT', 'TRUMPUSDT']; // Default top coins
          }


      } catch (e) {
          console.error('Failed to load coins from localStorage:', e);
          updateErrorDisplay('Failed to load coin list. Data might be corrupted.');
          coins = [...defaultCoins]; // Fallback to default on error
          topCoins = ['BTCUSDT', 'SUIUSDT', 'XRPUSDT', 'PEPEUSDT', 'TRUMPUSDT']; // Fallback to default top coins
      }
  }

  function removeManualCalcDataForCoin(symbol) {
      for (let i = 1; i <= 5; i++) {
          const savedData = localStorage.getItem(`manualCalcData${i}`);
          if (savedData) {
              try {
                  const data = JSON.parse(savedData);
                  if (data.symbol === symbol) {
                      localStorage.removeItem(`manualCalcData${i}`);
                      console.log(`Removed manual calc data for ${symbol} (Calc ${i}).`);
                      // Clear the corresponding manual calculator fields in the UI
                      document.getElementById(`manualCoinSelect${i}`).value = coins[0]?.symbol || ''; // Reset to default/first coin
                      document.getElementById(`manualAmount${i}`).value = '';
                      document.getElementById(`manualInvest${i}`).value = '';
                      document.getElementById(`manualBuyPrice${i}`).value = '';
                      updateManualCalc(i); // Update the display for this calc
                  }
              } catch (e) {
                  console.error(`Error parsing manual calc data for Calc ${i}:`, e);
              }
          }
      }
      calculateTotalManualProfit(); // Recalculate total after potentially removing data
  }

  // --- Dark Mode Functions ---
  function toggleDarkMode() {
      isDarkMode = !isDarkMode;
      const body = document.body;
      if (isDarkMode) {
          body.classList.add('dark-mode');
          localStorage.setItem('darkMode', 'enabled');
      } else {
          body.classList.remove('dark-mode');
          localStorage.setItem('darkMode', 'disabled');
      }
      // Update any elements that might need dynamic color adjustments based on mode
      // (Most styling is handled by CSS classes, but some JS-driven colors might need update)
      updateAllManualCalcs(); // Re-run calcs to update profit colors if needed (though CSS should handle this)
  }

  function loadDarkModeSetting() {
      const savedSetting = localStorage.getItem('darkMode');
      if (savedSetting === 'enabled') {
          isDarkMode = true;
          document.body.classList.add('dark-mode');
      } else {
          isDarkMode = false;
          document.body.classList.remove('dark-mode');
      }
  }


  // --- Time Functions ---
  function tick() {
    const now = new Date();
    document.getElementById('clock').textContent =
      'BD Time: ' + now.toLocaleTimeString('en-US', { timeZone:'Asia/Dhaka', hour12:true });
  }
  setInterval(tick, 1000);
  tick();

  function updateTimestamp() {
    const now = new Date();
    document.getElementById('timestamp').textContent =
      'Updated: ' +
      now.toLocaleTimeString('en-US',{ timeZone:'America/New_York', hour12:true }) +
      ' NYC | ' +
      now.toLocaleTimeString('en-US',{ timeZone:'Asia/Dhaka', hour12:true }) +
      ' BDT';
  }

  // --- Calculator Functions ---
  function step(id, dir) {
    const inp = document.getElementById(id);
    let valueStr = inp.value.trim();
    if (valueStr === '' || isNaN(parseFloat(valueStr))) valueStr = "0";

    // Use standard number stepping for simplicity and robustness
    let currentValue = parseFloat(inp.value) || 0;
    const stepValue = (id === 'fee') ? 0.001 : (inp.step === 'any' ? 0.000001 : parseFloat(inp.step) || 1); // Adjust step based on input type
    let newValue = currentValue + (dir * stepValue);

    // Handle precision for fees or other specific inputs
    if (id === 'fee') {
        newValue = parseFloat(newValue.toFixed(3)); // Fee precision
    } else if (inp.step === 'any') {
         // Attempt to maintain reasonable precision for 'any' step
         const currentPrecision = (valueStr.split('.')[1] || '').length;
         newValue = parseFloat(newValue.toFixed(Math.max(currentPrecision, 6))); // Use current or default precision
    }

    // Prevent negative values for price/investment if necessary (optional)
    // if (id !== 'fee' && newValue < 0) newValue = 0;

    inp.value = newValue;
    updateCalc();
    // If fee is changed, update all manual calculators
    if (id === 'fee') {
        updateAllManualCalcs();
    }
  }

  function updateCalc() {
    const totalFeePercent = parseFloat(document.getElementById('fee').value) || 0;
    const perTransactionFee = (totalFeePercent / 2) / 100;
    const inv = parseFloat(document.getElementById('inv').value) || 0;
    const buy = parseFloat(document.getElementById('buy').value) || 0;
    const sell = parseFloat(document.getElementById('sell').value) || 0;
    const coinsAmt = buy > 0 ? (inv / buy) * (1 - perTransactionFee) : 0;
    const totalReceived = coinsAmt * sell * (1 - perTransactionFee);
    const prof = totalReceived - inv;
    const pf = document.getElementById('profit');
    pf.textContent = prof.toFixed(2) + ' USDT';
    // Use background color classes for the main calculator
    pf.className = 'input compact-profit-display text-center flex-grow min-w-[150px] md:min-w-[180px]'; // Reset base classes
    pf.classList.add(prof >= 0 ? 'profit-positive-bg' : 'profit-negative-bg');

    // Also update table headers (will be called again in renderTable)
    updateProfitHeaders(inv);
  }
  // updateCalc(); // Initial calculation - moved to DOMContentLoaded


  // --- Manual Profit Calculator Functions ---

  // Function to save manual calculator data to localStorage
  function saveManualCalcData(calcIndex) {
      const selectedSymbol = document.getElementById(`manualCoinSelect${calcIndex}`).value;
      const amount = document.getElementById(`manualAmount${calcIndex}`).value;
      const invest = document.getElementById(`manualInvest${calcIndex}`).value;
      const buyPrice = document.getElementById(`manualBuyPrice${calcIndex}`).value;

      const dataToSave = {
          symbol: selectedSymbol,
          amount: amount,
          invest: invest,
          buyPrice: buyPrice
      };

      try {
          // Only save if at least one field has a value (or the coin is selected)
          if (selectedSymbol || amount || invest || buyPrice) {
             localStorage.setItem(`manualCalcData${calcIndex}`, JSON.stringify(dataToSave));
             // console.log(`Manual Calc ${calcIndex} data saved.`);
          } else {
             // If all fields are empty, remove the data from storage
             localStorage.removeItem(`manualCalcData${calcIndex}`);
             // console.log(`Manual Calc ${calcIndex} data cleared from storage.`);
          }

      } catch (e) {
          console.error(`Failed to save data for Manual Calc ${calcIndex}:`, e);
          updateErrorDisplay('Failed to save calculator data. Browser storage might be full or disabled.');
      }
  }

  // Function to load manual calculator data from localStorage
  function loadManualCalcData(calcIndex) {
      try {
          const savedData = localStorage.getItem(`manualCalcData${calcIndex}`);
          if (savedData) {
              const data = JSON.parse(savedData);
              const selectElement = document.getElementById(`manualCoinSelect${calcIndex}`);
              const amountInput = document.getElementById(`manualAmount${calcIndex}`);
              const investInput = document.getElementById(`manualInvest${calcIndex}`);
              const buyPriceInput = document.getElementById(`manualBuyPrice${calcIndex}`);

              // Check if the saved symbol exists in the current coin list
              const coinExists = coins.some(coin => coin.symbol === data.symbol);

              if (selectElement && coinExists) {
                  selectElement.value = data.symbol;
              } else if (selectElement) {
                   // If saved coin doesn't exist, keep the default or first option
                   console.warn(`Saved coin ${data.symbol} for Calc ${calcIndex} not found in current list. Using default.`);
                   // Find the default coin symbol for this calculator index
                   const defaultManualCalcCoins = { 1: 'SUIUSDT', 2: 'PEPEUSDT', 3: 'XRPUSDT', 4: 'XRPUSDT', 5: 'TRUMPUSDT' };
                   const defaultCoinSymbol = defaultManualCalcCoins[calcIndex];
                   selectElement.value = coins.find(c => c.symbol === defaultCoinSymbol)?.symbol || coins[0]?.symbol || ''; // Fallback to first coin
              }

              if (amountInput) amountInput.value = data.amount;
              if (investInput) investInput.value = data.invest;
              if (buyPriceInput) buyPriceInput.value = data.buyPrice;

              // console.log(`Manual Calc ${calcIndex} data loaded.`);
          } else {
              // If no saved data, ensure fields are empty/default
              const selectElement = document.getElementById(`manualCoinSelect${calcIndex}`);
              const amountInput = document.getElementById(`manualAmount${calcIndex}`);
              const investInput = document.getElementById(`manualInvest${calcIndex}`);
              const buyPriceInput = document.getElementById(`manualBuyPrice${calcIndex}`);
              // Find the default coin symbol for this calculator index
              const defaultManualCalcCoins = { 1: 'SUIUSDT', 2: 'PEPEUSDT', 3: 'XRPUSDT', 4: 'XRPUSDT', 5: 'TRUMPUSDT' };
              const defaultCoinSymbol = defaultManualCalcCoins[calcIndex];
              if (selectElement) selectElement.value = coins.find(c => c.symbol === defaultCoinSymbol)?.symbol || coins[0]?.symbol || ''; // Fallback to first coin
              if (amountInput) amountInput.value = '';
              if (investInput) investInput.value = '';
              if (buyPriceInput) buyPriceInput.value = '';
          }
      } catch (e) {
          console.error(`Failed to load data for Manual Calc ${calcIndex}:`, e);
          updateErrorDisplay('Failed to load calculator data. Data might be corrupted.');
          // On error, clear the data for this calculator
          localStorage.removeItem(`manualCalcData${calcIndex}`);
           const selectElement = document.getElementById(`manualCoinSelect${calcIndex}`);
              const amountInput = document.getElementById(`manualAmount${calcIndex}`);
              const investInput = document.getElementById(`manualInvest${calcIndex}`);
              const buyPriceInput = document.getElementById(`manualBuyPrice${calcIndex}`);
              // Find the default coin symbol for this calculator index
              const defaultManualCalcCoins = { 1: 'SUIUSDT', 2: 'PEPEUSDT', 3: 'XRPUSDT', 4: 'XRPUSDT', 5: 'TRUMPUSDT' };
              const defaultCoinSymbol = defaultManualCalcCoins[calcIndex];
              if (selectElement) selectElement.value = coins.find(c => c.symbol === defaultCoinSymbol)?.symbol || coins[0]?.symbol || ''; // Fallback to first coin
              if (amountInput) amountInput.value = '';
              if (investInput) investInput.value = '';
              if (buyPriceInput) buyPriceInput.value = '';
      }
  }


  // Modified updateManualCalc to accept index and update inline table profit
  function updateManualCalc(calcIndex) {
      // Get elements specific to this calculator instance
      const selectedSymbol = document.getElementById(`manualCoinSelect${calcIndex}`).value;
      const amountInput = document.getElementById(`manualAmount${calcIndex}`);
      const investInput = document.getElementById(`manualInvest${calcIndex}`);
      const buyPriceInput = document.getElementById(`manualBuyPrice${calcIndex}`);

      const amount = parseFloat(amountInput.value) || 0;
      const invest = parseFloat(investInput.value) || 0;
      const buyPrice = parseFloat(buyPriceInput.value) || 0;
      const totalFeePercent = parseFloat(document.getElementById('fee').value) || 0; // Use global fee
      const perTransactionFee = (totalFeePercent / 2) / 100; // Fee applied twice (buy and sell)

      const manualCurrentPriceSpan = document.getElementById(`manualCurrentPrice${calcIndex}`);
      const manualProfitDisplay = document.getElementById(`manualProfit${calcIndex}`);

      // Find the current price of the selected coin from the fetched data
      const coinData = allTableData.find(coin => coin.symbol === selectedSymbol);
      let currentPrice = NaN;
      if (coinData && !isNaN(coinData.last)) {
          currentPrice = coinData.last;
          // Format current price using the coin's precision
          const currentPrecision = precision[selectedSymbol] || 8;
          manualCurrentPriceSpan.textContent = currentPrice.toFixed(currentPrecision);
      } else {
          manualCurrentPriceSpan.textContent = 'N/A';
          manualProfitDisplay.textContent = 'N/A';
          manualProfitDisplay.className = 'manual-profit-display'; // Reset classes
          updateTableInlineProfits(); // Update table even if this calc is N/A
          calculateTotalManualProfit(); // Recalculate total profit
          return; // Cannot calculate profit without current price
      }

      let manualProfit = 0;
      let calculatedAmount = 0;
      let initialInvestment = 0;

      // Determine if using Coin Amount or USDT Invest
      if (amount > 0 && buyPrice > 0) {
          calculatedAmount = amount;
          initialInvestment = calculatedAmount * buyPrice / (1 - perTransactionFee); // Back-calculate investment before fee
          // Clear the other input field to avoid confusion
          // investInput.value = '';
      } else if (invest > 0 && buyPrice > 0) {
          // Calculate coin amount from USDT Invest and Buy Price, considering buy fee
          calculatedAmount = (invest / buyPrice) * (1 - perTransactionFee);
          initialInvestment = invest; // Initial investment is the USDT amount
          // Clear the other input field
          // amountInput.value = '';
      } else {
           manualProfitDisplay.textContent = '0.00 USDT';
           manualProfitDisplay.className = 'manual-profit-display'; // Reset classes
           updateTableInlineProfits(); // Update table
           calculateTotalManualProfit(); // Recalculate total profit
           return;
      }


      if (calculatedAmount > 0 && buyPrice > 0 && !isNaN(currentPrice)) {
          // Calculate potential revenue including sell fee
          const potentialRevenue = (calculatedAmount * currentPrice) * (1 - perTransactionFee);
           // Calculate profit based on initial investment
          manualProfit = potentialRevenue - initialInvestment;
      }


      manualProfitDisplay.textContent = manualProfit.toFixed(2) + ' USDT';
      // Use text color classes for manual profit display
      manualProfitDisplay.className = 'manual-profit-display'; // Reset base classes
      manualProfitDisplay.classList.toggle('profit-positive', manualProfit >= 0);
      manualProfitDisplay.classList.toggle('profit-negative', manualProfit < 0);
      // Add background classes for manual profit display
      manualProfitDisplay.classList.toggle('profit-positive-bg', manualProfit >= 0);
      manualProfitDisplay.classList.toggle('profit-negative-bg', manualProfit < 0);


      // Update the inline profit display in the table
      updateTableInlineProfits();
      calculateTotalManualProfit(); // Recalculate total profit
  }

  // NEW Function: Update inline profit displays in the table
  function updateTableInlineProfits() {
      // Clear all existing inline profit displays first
      document.querySelectorAll('.manual-profit-inline').forEach(span => {
          span.textContent = '';
          // Keep the ml-2 and text-sm classes, remove color classes
          span.className = 'manual-profit-inline ml-2 text-sm';
      });

      // Loop through each manual calculator (1 to 5)
      for (let calcIndex = 1; calcIndex <= 5; calcIndex++) {
          const selectElement = document.getElementById(`manualCoinSelect${calcIndex}`);
          const profitElement = document.getElementById(`manualProfit${calcIndex}`);

          // Check if the elements exist (they should for all 5)
          if (!selectElement || !profitElement) continue;

          const selectedSymbol = selectElement.value;
          const profitText = profitElement.textContent;
          const isPositive = profitElement.classList.contains('profit-positive');
          const isNegative = profitElement.classList.contains('profit-negative');

          // Check if profit is calculated and valid
          if (profitText.includes('USDT') && (isPositive || isNegative)) {
              const profitValue = parseFloat(profitText.replace(' USDT', ''));
              if (!isNaN(profitValue)) {
                  // Find the corresponding span in the table body
                  const targetSpan = document.querySelector(`#body .manual-profit-inline[data-coin-symbol='${selectedSymbol}']`);
                  if (targetSpan) {
                      // Update the span content to show "Profit +X.XX$" or "Loss -X.XX$"
                      const label = profitValue >= 0 ? 'Profit' : 'Loss';
                      const sign = profitValue >= 0 ? '+' : '-';
                      targetSpan.textContent = `${label} ${sign}${Math.abs(profitValue).toFixed(2)}$`;
                      // Add color classes
                      targetSpan.classList.add(isPositive ? 'profit-positive' : 'profit-negative');
                  }
              }
          }
      }
  }


  // NEW Function: Calculate and display total manual profit
  function calculateTotalManualProfit() {
      let totalProfit = 0;
      for (let i = 1; i <= 5; i++) {
          const profitElement = document.getElementById(`manualProfit${i}`);
          // Check if the profit element exists (it should for all 5)
          if (profitElement) {
              const profitText = profitElement.textContent;
              if (profitText.includes('USDT')) {
                  const profitValue = parseFloat(profitText.replace(' USDT', ''));
                  if (!isNaN(profitValue)) {
                      totalProfit += profitValue;
                  }
              }
          }
      }

      // Update the total profit display
      const totalProfitElement = document.getElementById('manualTotalProfit');
      if (totalProfitElement) {
          totalProfitElement.textContent = totalProfit.toFixed(2) + ' USDT';
          // Use text color classes for total profit display
          totalProfitElement.className = 'manual-profit-display font-bold text-center flex-grow min-w-[150px] md:min-w-[180px]'; // Reset base classes
          totalProfitElement.classList.toggle('profit-positive', totalProfit >= 0);
          totalProfitElement.classList.toggle('profit-negative', totalProfit < 0);
           // Add background classes for total profit display
          totalProfitElement.classList.toggle('profit-positive-bg', totalProfit >= 0);
          totalProfitElement.classList.toggle('profit-negative-bg', totalProfit < 0);
      }
  }

  // Modified updateAllManualCalcs to simply call updateManualCalc for each and then calculate total
  function updateAllManualCalcs() {
      for (let i = 1; i <= 5; i++) {
          // Check if the element exists before updating
          if (document.getElementById(`manualCoinSelect${i}`)) {
              updateManualCalc(i); // This now handles individual calc update AND triggers table update
          }
      }
      // Total calculation is handled within updateManualCalc now.
      // calculateTotalManualProfit(); // This call is now redundant here as updateManualCalc calls it.
  }

  // Modified populateManualCoinSelect to set new defaults and XRP for Calc 4
  function populateManualCoinSelect() {
      // Define default coins for each calculator index (1-based)
      const defaultManualCalcCoins = {
          1: 'SUIUSDT',
          2: 'PEPEUSDT',
          3: 'XRPUSDT',
          4: 'XRPUSDT',
          5: 'TRUMPUSDT'
      };

      const selects = document.querySelectorAll('.manualCoinSelect'); // Select all dropdowns
      selects.forEach((select, index) => {
          select.innerHTML = ''; // Clear existing options
          // Sort coins alphabetically by name for the dropdown
          const sortedCoins = [...coins].sort((a, b) => a.name.localeCompare(b.name));
          sortedCoins.forEach(coin => {
              const option = document.createElement('option');
              option.value = coin.symbol;
              option.textContent = coin.name;
              select.appendChild(option);
          });

          // Set default selected coin based on the calculator index (1-based)
          const calcIndex = index + 1;
          const defaultCoinSymbol = defaultManualCalcCoins[calcIndex];

          // Try to load saved coin first
          const savedData = localStorage.getItem(`manualCalcData${calcIndex}`);
          let selectedSymbol = savedData ? JSON.parse(savedData).symbol : null;

          // If no saved coin or saved coin not in current list, use default
          if (!selectedSymbol || !coins.some(c => c.symbol === selectedSymbol)) {
              selectedSymbol = defaultCoinSymbol;
          }

           // Ensure the selected coin exists in the current coin list before setting
          if (selectedSymbol && coins.some(c => c.symbol === selectedSymbol)) {
              select.value = selectedSymbol;
          } else {
              select.value = sortedCoins[0]?.symbol || ''; // Fallback to first coin if default not found
          }

          // Initial calculation for this calculator (will also trigger table update)
          // updateManualCalc(calcIndex); // Moved initial calculation to DOMContentLoaded
      });
  }

  // NEW Function: Toggle visibility of hidden calculators
  function toggleHiddenCalcs() {
      const hiddenContainer = document.getElementById('hiddenManualCalcs');
      const showMoreBtn = document.getElementById('showMoreCalcsBtn');

      // Check the current display style to determine state
      const isHidden = hiddenContainer.style.display === 'none' || hiddenContainer.style.display === '';

      if (isHidden) {
          hiddenContainer.style.display = 'flex'; // Use flex to maintain layout
          hiddenContainer.style.flexDirection = 'column'; // Stack rows vertically
          hiddenContainer.style.gap = '0.5rem'; // Add gap between rows
          showMoreBtn.textContent = 'Hide Extra Calculators';
      } else {
          hiddenContainer.style.display = 'none';
          showMoreBtn.textContent = 'Show More Calculators';
      }
      // Recalculate total profit just in case (though updateManualCalc should handle it)
      calculateTotalManualProfit();
  }

  // --- Coin Management Functions ---
  function addCoin() {
      const input = document.getElementById('coinSymbolInput');
      const symbol = input.value.trim().toUpperCase(); // Use uppercase for consistency

      if (!symbol) {
          updateErrorDisplay('Enter symbol to add.');
          return;
      }

      // Check if the coin already exists in the list
      if (coins.some(coin => coin.symbol === symbol)) {
          updateErrorDisplay(`${symbol} already in list.`);
          input.value = ''; // Clear input
          return;
      }

      // Basic validation: Check if it ends with USDT (a common pair)
      if (!symbol.endsWith('USDT')) {
           updateErrorDisplay(`Invalid format. Use USDT pair (e.g., ${symbol}USDT).`);
           return;
      }

      // Add the new coin object. We'll need a placeholder name and label.
      // Realistically, we might need to fetch basic info like name, but for simplicity, use symbol as name.
      const newCoin = {
          symbol: symbol,
          name: symbol.replace('USDT', ''), // Use symbol without USDT as name
          label: 'Custom', // Label for user-added coins
          // No highlight by default for custom coins
      };

      coins.push(newCoin); // Add to the end of the list (All Coins)
      saveCoins(); // Save the updated list
      input.value = ''; // Clear the input field
      updateErrorDisplay(''); // Clear any previous error message
      console.log(`Added coin: ${symbol}`);

      // Refresh data and table
      populateManualCoinSelect(); // Update manual calculator dropdowns
      loadData(); // Fetch data for the new coin and re-render table
  }

  function removeCoin() {
      const input = document.getElementById('coinSymbolInput');
      const symbolToRemove = input.value.trim().toUpperCase(); // Use uppercase

      if (!symbolToRemove) {
          updateErrorDisplay('Enter symbol to remove.');
          return;
      }

      // Check if the coin exists in the list
      const initialLength = coins.length;
      coins = coins.filter(coin => coin.symbol !== symbolToRemove);

      if (coins.length === initialLength) {
          updateErrorDisplay(`${symbolToRemove} not found.`);
          input.value = ''; // Clear input
          return;
      }

      // Also remove from topCoins if it was a top coin
      topCoins = topCoins.filter(symbol => symbol !== symbolToRemove);

      // Remove associated manual calculator data
      removeManualCalcDataForCoin(symbolToRemove);

      saveCoins(); // Save the updated list
      input.value = ''; // Clear the input field
      updateErrorDisplay(''); // Clear any previous error message
      console.log(`Removed coin: ${symbolToRemove}`);

      // Refresh data and table
      populateManualCoinSelect(); // Update manual calculator dropdowns
      loadData(); // Re-fetch data and re-render table
  }

  // NEW Function: Toggle coin in topCoins list
  function toggleTopCoin(symbol) {
      const index = topCoins.indexOf(symbol);
      if (index > -1) {
          // Coin is in topCoins, remove it
          topCoins.splice(index, 1);
          console.log(`Removed ${symbol} from Top Coins.`);
      } else {
          // Coin is not in topCoins, add it
          topCoins.push(symbol);
          console.log(`Added ${symbol} to Top Coins.`);
      }
      saveCoins(); // Save the updated topCoins list
      renderTable(); // Re-render the table to update star icons/filtering
  }


  // Reset Coins function removed as requested
  // function resetCoins() { ... }


  // --- Data Fetching and Processing ---

  // Function to fetch RSI data from Binance API
  async function getRSI(sym, interval = '15m'){
    try {
        const limit = 15; // Need 14 periods + 1 initial value
        const apiUrl = `https://api.binance.com/api/v3/klines?symbol=${sym}&interval=${interval}&limit=${limit}`;
        const response = await fetch(apiUrl);
        if (!response.ok) {
            handleApiError(response, `RSI klines for ${sym} (${interval})`);
            return NaN;
        }
        const kl = await response.json();
        if (!kl || !Array.isArray(kl) || kl.length < 14) { console.warn(`Not enough data for ${sym} on ${interval} interval.`); return NaN; }

        // Calculate RSI (Simplified - using only the fetched period, not historical smoothing)
        let gains = 0, losses = 0;
        const closes = kl.map(c => +c[4]);
        for(let i = 1; i < closes.length; i++){
            const diff = closes[i] - closes[i-1];
            if (diff > 0) gains += diff; else losses -= diff;
        }
        const period = closes.length - 1;
        if (period === 0) return NaN;
        const avgGain = gains / period; const avgLoss = losses / period;
        if (avgLoss === 0) return avgGain > 0 ? 100 : 50; // Handle division by zero (fully bullish or neutral)
        const rs = avgGain / avgLoss;
        const rsi = 100 - (100 / (1 + rs));
        return rsi;
    } catch (error) {
        console.error(`Error fetching RSI for ${sym} (${interval}):`, error);
        updateErrorDisplay(`Error fetching RSI for ${sym}. Check console.`);
        return NaN;
    }
  }

  // Function to fetch Order Book Depth data from Binance API (Only used for pressure indicators now)
  async function getDepthData(symbol, limit = 20) {
      try {
          const apiUrl = `https://api.binance.com/api/v3/depth?symbol=${symbol}&limit=${limit}`;
          const response = await fetch(apiUrl);
          if (!response.ok) {
              handleApiError(response, `Depth for ${symbol}`);
              return null;
          }
          const data = await response.json();
          return data;
      } catch (error) {
          console.error(`Error fetching depth for ${symbol}:`, error);
          updateErrorDisplay(`Error fetching depth for ${symbol}. Check console.`);
          return null;
      }
  }

  // Removed findLargestWall function

  // Function to calculate pressure from depth data (reused)
  function calculatePressure(depthData) {
      if (!depthData || !depthData.bids || !depthData.asks) return { type: 'Neutral', percentage: 50 };
      let totalBids = depthData.bids.reduce((sum, bid) => sum + parseFloat(bid[1]), 0);
      let totalAsks = depthData.asks.reduce((sum, ask) => sum + parseFloat(ask[1]), 0);
      const totalVolume = totalBids + totalAsks;
      if (totalVolume === 0) return { type: 'Neutral', percentage: 50 };
      const bidPercentage = (totalBids / totalVolume) * 100;
      const askPercentage = 100 - bidPercentage;
      const threshold = 1.1; // 10% difference threshold
      if (bidPercentage > askPercentage * threshold) return { type: 'Buy', percentage: bidPercentage.toFixed(0) };
      if (askPercentage > bidPercentage * threshold) return { type: 'Sell', percentage: askPercentage.toFixed(0) };
      return { type: 'Neutral', percentage: 50 };
  }

  // Function to update the individual pressure displays (reused)
  async function updatePressureDisplays() {
      const pressureDivs = {
          'BTCUSDT': document.getElementById('btc-pressure-small'),
          'SUIUSDT': document.getElementById('sui-pressure-small'),
          'PEPEUSDT': document.getElementById('pepe-pressure-small')
      };
      for (const symbol of pressureCoins) {
          const depthData = await getDepthData(symbol); // Fetch fresh data each time
          const pressure = calculatePressure(depthData);
          const coinName = symbol.replace('USDT', '');
          const pressureDiv = pressureDivs[symbol]; // Get the correct div
          if (pressureDiv) {
              if (pressure) {
                  pressureDiv.textContent = `${coinName} ${pressure.type} ${pressure.percentage}%`;
                  pressureDiv.className = `small-pressure-display ${pressure.type.toLowerCase()}`; // Reset classes
              } else {
                   pressureDiv.textContent = `${coinName} N/A`;
                   pressureDiv.className = 'small-pressure-display neutral'; // Reset classes
              }
          }
      }
  }

  // Helper function to handle API errors and update UI (reused)
  function handleApiError(response, context) {
      console.warn(`API error fetching ${context}: ${response.status}`);
      const rateLimitMessages = [
          'API rate limit likely hit. Data refresh may be delayed.',
          'High frequency may cause rate limits.'
      ];
      if (response.status === 429 || response.status === 418) {
           console.warn('API rate limit likely hit.');
           document.getElementById('rate-limit-warning').classList.remove('hidden'); // Keep showing the warning span
      } else {
           updateErrorDisplay(`API error for ${context} (${response.status}).`); // Show other API errors
      }
  }

  // Helper function to update the error display area (reused)
  function updateErrorDisplay(message) {
      const errorDiv = document.getElementById('error');
      // Filter out specific rate limit messages
      const rateLimitMessages = [
          'API rate limit likely hit. Data refresh may be delayed.',
          'High frequency may cause rate limits.'
      ];
      if (rateLimitMessages.includes(message)) {
          // Do not display these specific messages in the error div
          console.log(`Suppressed error message: ${message}`);
          return;
      }

      // Clear the error message if the same message is received again
      if (errorDiv.textContent.includes(message)) {
           // Do nothing, avoid duplicate messages
      } else {
          // Add new message, prepend with '|' if there are existing messages
          errorDiv.textContent = (errorDiv.textContent ? errorDiv.textContent + ' | ' : '') + message;
      }
  }

  // Function to load GLOBAL metrics (Market Cap, F&G)
  async function loadGlobalMetrics() {
      console.log("Loading global metrics...");
      try {
          const [globalRes, fngRes] = await Promise.all([
              fetch('https://api.coingecko.com/api/v3/global').catch(e => { console.error("Gecko API Error:", e); return null; }),
              fetch('https://api.alternative.me/fng/?limit=1').catch(e => { console.error("FNG API Error:", e); return null; })
          ]);
          let metricsHtml = '';
          if (globalRes && globalRes.ok) {
              const g = await globalRes.json();
              const mcap = g.data.total_market_cap.usd / 1e9;
              const chg = g.data.market_cap_change_percentage_24h_usd;
              const chgColorClass = chg >= 0 ? 'pct-green' : 'pct-red';
              metricsHtml += `Market Cap: $${mcap.toFixed(2)}B (<span class="${chgColorClass}">${chg.toFixed(2)}%</span>)`;
          } else {
              metricsHtml += 'Market Cap: N/A';
          }

          if (fngRes && fngRes.ok) {
              const f = await fngRes.json();
              const fgv = f.data[0].value;
              const fgc = f.data[0].value_classification;
              metricsHtml += ` | F&G: <span style="color:${fgc.toLowerCase().includes('fear')?'#f06548':'#0ab39c'}">${fgv}</span> (${fgc})`;
          } else {
               metricsHtml += ' | F&G: N/A';
          }

          document.getElementById('metrics').innerHTML = metricsHtml;

      } catch (error) {
          console.error("Critical Error in loadGlobalMetrics:", error);
          updateErrorDisplay('Failed to load global metrics. Check console.');
      }
  }


  // Function to load coin-specific data (Ticker, RSI, Depth, CoinGecko)
  async function loadData(){
    console.log(`Loading coin data - RSI: ${currentRsiInterval}, Page: ${currentPage}`);
    updateErrorDisplay(''); // Clear previous errors on new load attempt
    // document.getElementById('rate-limit-warning').classList.add('hidden'); // Hide warning initially - Keep it visible if high frequency page is active

    try {
        updateTimestamp(); // Update timestamp on each data load

        // --- Fetch Coin-Specific Data ---
        const binanceSymbols = coins.map(c => c.symbol);

        // Fetch 24hr ticker data (High Frequency - essential for price updates)
        const binanceTickerPromises = binanceSymbols.map(symbol =>
            fetch(`https://api.binance.com/api/v3/ticker/24hr?symbol=${symbol}`)
            .then(res => res.ok ? res.json() : Promise.reject(res)) // Reject promise on non-OK status
            .catch(res => { handleApiError(res, `Ticker for ${symbol}`); return null; }) // Handle error and return null
        );

        // Fetch RSI data (Lower Frequency - less critical for second-by-second updates)
        // Consider fetching this less often if rate limits are hit
        const binanceRsiPromises = binanceSymbols.map(symbol => getRSI(symbol, currentRsiInterval));

        // Fetch Depth data for pressure coins (Lower Frequency) - This is now only for pressure displays
        const pressureUpdatePromise = updatePressureDisplays();


        // Fetch CoinGecko data (Lowest Frequency - ATH/ATL/Market Cap change slowly)
        // This is now handled by loadGlobalMetrics, but we still need ATH/ATL/MarketCap per coin for the table.
        // We can fetch this less frequently or cache it. For now, let's keep fetching it with coin data.
        const coinGeckoIdMapForFetch = {...coinGeckoIdMap};
        // Remove TRUMPUSDT from the map for CoinGecko fetch as it doesn't have a standard CG ID
        delete coinGeckoIdMapForFetch['TRUMPUSDT']; // Example: remove TRUMP if it doesn't have a CG ID

        const coinGeckoIds = coins.map(c => coinGeckoIdMapForFetch[c.symbol]).filter(id => id); // Filter out undefined IDs
        const coinGeckoIdsString = coinGeckoIds.join(',');
         // Only fetch CoinGecko if there are valid IDs to fetch
        const coinGeckoPromise = coinGeckoIds.length > 0 ? fetch(`https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=${coinGeckoIdsString}&order=market_cap_desc&per_page=100&page=1&sparkline=false`)
            .then(res => res.ok ? res.json() : Promise.reject(res))
            .catch(res => { handleApiError(res, `CoinGecko Markets`); return []; })
            : Promise.resolve([]);


        // Wait for all API calls
        const [binanceTickerResults, binanceRsiResults, coinGeckoData, _pressureResult] = await Promise.all([
            Promise.allSettled(binanceTickerPromises),
            Promise.allSettled(binanceRsiPromises),
            coinGeckoPromise, // Already handles its catch
            pressureUpdatePromise // Wait for pressure display to finish
        ]);

        // Create a map for quick lookup of CoinGecko data
        const coinGeckoDataMap = {};
        if (Array.isArray(coinGeckoData)) {
            coinGeckoData.forEach(coin => {
                const binanceSymbol = Object.keys(coinGeckoIdMapForFetch).find(key => coinGeckoIdMapForFetch[key] === coin.id);
                if (binanceSymbol) coinGeckoDataMap[binanceSymbol] = coin;
            });
        }

        // Merge data
        const newTableData = [];
        let apiErrorCount = 0;
        coins.forEach((coin, index) => {
            const binanceTickerResult = binanceTickerResults[index];
            const binanceRsiResult = binanceRsiResults[index];
            const cgData = coinGeckoDataMap[coin.symbol]; // Will be undefined if no CG ID or fetch failed

            let low = NaN, high = NaN, last = NaN, prev = NaN, volume = NaN, pct = NaN, rsiValue = NaN;
            // Removed largestBid and largestAsk properties
            let ath = NaN, atl = NaN, marketCap = NaN;

            // Process Binance Ticker Data
            if (binanceTickerResult.status === 'fulfilled' && binanceTickerResult.value) {
                 const d = binanceTickerResult.value;
                 low = +d.lowPrice; high = +d.highPrice; last = +d.lastPrice;
                 prev = +d.prevClosePrice; volume = +d.quoteVolume;
                 pct = prev != 0 ? ((last - prev) / prev) * 100 : 0;
            } else {
                 apiErrorCount++;
                 console.warn(`Failed to get Binance ticker data for ${coin.symbol}.`);
            }

            // Process Binance RSI Data
             if (binanceRsiResult.status === 'fulfilled') {
                 rsiValue = binanceRsiResult.value;
             } else {
                 // Don't count as a full API error if only RSI fails, but log it
                 console.warn(`Failed to get Binance RSI data for ${coin.symbol}.`);
             }

            // Removed processing for Binance Depth Data for table columns

            // Process CoinGecko Data (Use existing data if available, otherwise fetch)
            if (cgData) {
                ath = cgData.ath; atl = cgData.atl; marketCap = cgData.market_cap;
                // Use CG as fallback if Binance failed
                if (isNaN(low) && cgData.low_24h) low = cgData.low_24h;
                if (isNaN(high) && cgData.high_24h) high = cgData.high_24h;
                if (isNaN(last) && cgData.current_price) last = cgData.current_price;
                if (isNaN(volume) && cgData.total_volume) volume = cgData.total_volume;
                if (isNaN(pct) && cgData.price_change_percentage_24h) pct = cgData.price_change_percentage_24h;
            } else if (coinGeckoIdMapForFetch[coin.symbol]) { // Only warn if we expected CG data
                 console.warn(`No CoinGecko data for ${coin.symbol}. ATH/ATL/MCap will be N/A.`);
            }

            newTableData.push({
                ...coin, low, high, last, prev, rsi: rsiValue, pct, volume,
                // Removed largestBid, largestAsk from here
                ath, atl, marketCap
            });
        });

        allTableData = newTableData; // Update the global data store

        if (apiErrorCount > 0) {
             // Modified error message to be less specific about rate limits
             // updateErrorDisplay(`Data errors for ${apiErrorCount} coin(s). Some data may be missing.`);
             // Keep the rate limit warning span visible if appropriate, but don't add a general error message here
        }

        renderTable(); // Render the table with the new data
        updateAllManualCalcs(); // Update all manual calculators with new current prices

    } catch (error) {
        console.error("Critical Error in loadData:", error);
        updateErrorDisplay('Failed to load data. Check console.');
    } finally {
        // Schedule the next refresh ONLY if auto-refresh is enabled
        if (isAutoRefreshEnabled) {
           scheduleNextRefresh();
        }
    }
  }

  // --- Suggestion and Formatting Functions ---
  function generateSuggestion(rsi, pctChange) {
      if (isNaN(rsi)) return 'N/A';
      // Simplified logic for brevity
      if (rsi < 30) return 'Oversold (Buy Watch)';
      if (rsi < 40) return 'Approaching Oversold';
      if (rsi > 70) return 'Overbought (Sell Watch)';
      if (rsi > 60) return 'Approaching Overbought';
      if (pctChange > 2) return 'Strong Up Trend';
      if (pctChange < -2) return 'Strong Down Trend';
      return 'Neutral / Range';
  }

  function generateMaSignal(rsi, pctChange) {
      if (isNaN(rsi)) return 'N/A';
      if (rsi > 55 && pctChange > 0.3) return 'Bullish';
      if (rsi < 45 && pctChange < -0.3) return 'Bearish';
      return 'Neutral';
  }

  function formatVolume(volume) {
      if (isNaN(volume) || volume === null) return 'N/A';
      if (volume >= 1e9) return (volume / 1e9).toFixed(2) + 'B';
      if (volume >= 1e6) return (volume / 1e6).toFixed(2) + 'M';
      if (volume >= 1e3) return (volume / 1e3).toFixed(1) + 'K';
      return volume.toFixed(0);
  }

  function formatMarketCap(mcap) { // Added function
      if (isNaN(mcap) || mcap === null) return 'N/A';
      if (mcap >= 1e12) return (mcap / 1e12).toFixed(2) + 'T';
      if (mcap >= 1e9) return (mcap / 1e9).toFixed(2) + 'B';
      if (mcap >= 1e6) return (mcap / 1e6).toFixed(2) + 'M';
      return mcap.toFixed(0);
  }

   // Removed formatWallVolume function


  // --- Table Rendering Function ---
  function updateProfitHeaders(investmentAmount) {
      const invStr = investmentAmount >= 1000 ? `${(investmentAmount / 1000).toFixed(0)}k` : investmentAmount.toFixed(0);
      const phHeader = document.getElementById('profitLowHighHeader');
      const pchHeader = document.getElementById('profitCurrentHighHeader');
      if (phHeader) phHeader.textContent = `$${invStr} L→H`; // Corrected header text
      if (pchHeader) pchHeader.textContent = `$${invStr} C→H`;
  }

  function renderTable(){
    const currentInvestment = parseFloat(document.getElementById('inv').value) || 1000;
    updateProfitHeaders(currentInvestment); // Update headers based on current investment

    const rsiHeader = document.getElementById('rsiHeader');
    if (rsiHeader) rsiHeader.textContent = `RSI (${currentRsiInterval})`;

    // Filter data based on the current page
    let dataToRender = [];
    if (currentPage === 'top4') {
        // Filter allTableData to include only coins whose symbols are in the topCoins array
        dataToRender = allTableData.filter(coin => topCoins.includes(coin.symbol));
    } else {
        dataToRender = [...allTableData]; // Use all data for the 'all' page
    }

    // Sort the filtered data
    if(sortKey){
      dataToRender.sort((a,b)=>{
        let va, vb;
        // --- Sorting logic based on sortKey ---
        if (sortKey === 'coin') { va = a.name; vb = b.name; } // Sort by name
        else if (sortKey === 'type') { va = a.label; vb = b.label; }
        else if (sortKey === 'signalSuggestion') {
            const signalA = generateMaSignal(a.rsi, a.pct); const signalB = generateMaSignal(b.rsi, b.pct);
            const suggestionA = generateSuggestion(a.rsi, a.pct); const suggestionB = generateSuggestion(b.rsi, b.pct); // Corrected suggestionB
            const signalOrder = { 'Bullish': 3, 'Neutral': 2, 'Bearish': 1, 'N/A': 0 };
            const orderA = signalOrder[signalA] || 0; const orderB = signalOrder[signalB] || 0;
            if (orderA !== orderB) { va = orderA; vb = orderB; }
            else { va = suggestionA; vb = suggestionB; return va.localeCompare(vb) * sortDir; } // Secondary sort by suggestion text
        }
         // Removed sorting for largestBid and largestAsk
        else if (['low','high','last','pH','pCH', 'volume', 'marketCap', 'ath', 'atl', 'rsi'].includes(sortKey)){
           const pH_a = a.low > 0 ? ((a.high - a.low) / a.low) * currentInvestment : 0;
           const pCH_a = a.last > 0 ? ((a.high - a.last) / a.last) * currentInvestment : 0;
           const pH_b = b.low > 0 ? ((b.high - b.low) / b.low) * currentInvestment : 0;
           const pCH_b = b.last > 0 ? ((b.high - b.last) / b.last) * currentInvestment : 0; // Corrected calculation for C->H profit

           if (sortKey === 'pH') { va = pH_a; vb = pH_b; } // Corrected comparison
           else if (sortKey === 'pCH') { va = pCH_a; vb = pCH_b; }
           else if (sortKey === 'volume') { va = a.volume; vb = b.volume; }
           else if (sortKey === 'marketCap') { va = a.marketCap; vb = b.marketCap; }
           else if (sortKey === 'ath') { va = a.ath; vb = b.ath; } // Corrected comparison
           else if (sortKey === 'atl') { va = a.atl; vb = b.atl; }
           else if (sortKey === 'rsi') { va = a.rsi; vb = b.rsi; }
           else { va = a[sortKey]; vb = b[sortKey]; } // Fallback for low, high, last

           // Handle NaN or null values - push them to the bottom when sorting descending, top when ascending
           const nanA = isNaN(va) || va === null;
           const nanB = isNaN(vb) || vb === null;
           if (nanA && nanB) return 0;
           if (nanA) return sortDir === 1 ? 1 : -1; // NaN is considered "smaller" when ascending
           if (nanB) return sortDir === 1 ? -1 : 1; // NaN is considered "smaller" when ascending

           va = parseFloat(va); vb = parseFloat(vb);
        } else { // Default case if sortKey is unknown (shouldn't happen)
            va = a[sortKey]; vb = b[sortKey];
        }

        // --- Comparison logic ---
        if (typeof va === 'string' && typeof vb === 'string') {
            return va.localeCompare(vb) * sortDir;
        } else {
            if (va > vb) return 1 * sortDir;
            if (va < vb) return -1 * sortDir;
            return 0;
        }
      });
    }

    // Populate Table Body
    const tb = document.getElementById('body');
    tb.innerHTML = ''; // Clear previous content
    if (dataToRender.length === 0) {
        const message = allTableData.length === 0 ? "Loading data or API error..." : "No coins match the current filter.";
        // Updated colspan to match the number of columns (now 9)
        tb.innerHTML = `<tr><td colspan="9" class="text-center p-4 text-gray-500">${message}</td></tr>`;
        return;
    }

    dataToRender.forEach(r => {
      const pct = r.pct;
      const tr = document.createElement('tr');
      tr.dataset.symbol = r.symbol; // Add data-symbol attribute to row
      // Only apply highlight if the highlight property exists
      if(r.highlight) { tr.classList.add('highlight-' + r.highlight); } // Apply highlight class

      const profitLowToHigh = r.low > 0 ? ((r.high - r.low) / r.low) * currentInvestment : 0;
      const profitCurrentToHigh = r.last > 0 ? ((r.high - r.last) / r.last) * currentInvestment : 0; // Corrected calculation
      const rsiValue = r.rsi; const rsiText = isNaN(rsiValue) ? 'N/A' : rsiValue.toFixed(1);
      const rsiClass = isNaN(rsiValue) ? '' : (rsiValue < 35 ? 'green' : (rsiValue > 65 ? 'red' : ''));
      const suggestionText = generateSuggestion(rsiValue, pct);
      let suggestionColorClass = '';
      if (suggestionText.includes('Buy')) suggestionColorClass = 'buy-color'; else if (suggestionText.includes('Sell')) suggestionColorClass = 'sell-color';
      const maSignalText = generateMaSignal(rsiValue, pct);
      let maSignalClass = '';
      if (maSignalText === 'Bullish') maSignalClass = 'bullish'; else if (maSignalText === 'Bearish') maSignalClass = 'bearish';

      // Format prices using the precision map
      const currentPrecision = precision[r.symbol] || 8; // Default to 8 if not specified
      const formatPrice = (price) => isNaN(price) ? 'N/A' : price.toFixed(currentPrecision);

      // Check if the coin is in the topCoins list to determine star icon state
      const isTopCoin = topCoins.includes(r.symbol);
      const starIconClass = isTopCoin ? 'fas fa-star' : 'far fa-star'; // Solid star if in topCoins, outline if not
      const starColorClass = isTopCoin ? 'is-top-coin' : ''; // Apply green color class if in topCoins


      tr.innerHTML = `
        <td class="text-left">
            <i class="${starIconClass} toggle-top-coin ${starColorClass}" data-symbol="${r.symbol}" title="${isTopCoin ? 'Remove from Top Coins' : 'Add to Top Coins'}"></i>
            <a href="https://www.binance.com/en/trade/${r.symbol}?type=spot" target="_blank" class="text-blue-600 hover:underline font-medium">${r.name}</a>
            <span class="${pct<0?'pct-red':'pct-green'} text-xs">(${isNaN(pct)?'N/A':pct.toFixed(1)}%)</span>
            <span class="manual-profit-inline ml-2 text-sm" data-coin-symbol="${r.symbol}"></span> </td>
        <td class="rsi clickable text-right ${rsiClass}" data-rsi-value="${rsiValue}">${rsiText}</td>
        <td class="last clickable text-right">${formatPrice(r.last)}</td>
        <td class="low clickable text-right">${formatPrice(r.low)}</td>
        <td class="high clickable text-right">${formatPrice(r.high)}</td>
        <td class="text-right">$${isNaN(profitLowToHigh)?'N/A':profitLowToHigh.toFixed(2)}</td>
        <td class="text-right">$${isNaN(profitCurrentToHigh)?'N/A':profitCurrentToHigh.toFixed(2)}</td>
        <td class="text-right">${formatVolume(r.volume)}</td>
        <td class="signal-suggestion clickable text-left">
            <span class="ma-signal ${maSignalClass}">${maSignalText}</span>
            <span class="suggestion-text ${suggestionColorClass}">${suggestionText}</span>
        </td>
        `;
      tb.appendChild(tr);
    });

    // Re-add event listeners after the table body is repopulated
    addTableEventListeners();

    // Populate inline profits after table is rendered
    updateTableInlineProfits();
  }

  // Function to add event listeners to table headers and cells
  function addTableEventListeners() {
    // Add sorting listeners to headers
    document.querySelectorAll('th.sortable').forEach(th => {
      // Clone and replace to remove old listeners safely
      const newTh = th.cloneNode(true);
      th.parentNode.replaceChild(newTh, th);

      newTh.onclick = () => {
        const key = newTh.dataset.key;
        if (sortKey === key) {
          sortDir = -sortDir; // Reverse direction
        } else {
          sortKey = key;
          // Default descending for volume/profit/mcap, ascending otherwise
          sortDir = (['volume', 'pCH', 'pH', 'marketCap'].includes(key)) ? -1 : 1;
        }
        // Reset RSI custom sort state if sorting by another column
        if (key !== 'rsi') rsiSortState = 'custom-asc';

        renderTable(); // Re-render the table with the new sort order
      };
    });

    // Add click listeners to price cells
    document.querySelectorAll('#body .low.clickable').forEach(c => c.onclick = () => { document.getElementById('buy').value = c.textContent; updateCalc(); });
    document.querySelectorAll('#body .high.clickable').forEach(c => c.onclick = () => { document.getElementById('sell').value = c.textContent; updateCalc(); });
    document.querySelectorAll('#body .last.clickable').forEach(c => c.onclick = () => { document.getElementById('buy').value = c.textContent; updateCalc(); });

    // Add click listeners to RSI cells
    document.querySelectorAll('#body .rsi.clickable').forEach(c => {
        c.onclick = () => {
            const rsiValue = parseFloat(c.dataset.rsiValue); if (isNaN(rsiValue)) return;
            const row = c.closest('tr'); const lastPriceCell = row.querySelector('.last.clickable');
            if (lastPriceCell) {
                const lastPrice = lastPriceCell.textContent;
                if (rsiValue < 35) { document.getElementById('buy').value = lastPrice; document.getElementById('sell').value = ''; }
                else if (rsiValue > 65) { document.getElementById('sell').value = lastPrice; document.getElementById('buy').value = ''; }
                updateCalc();
            }
        };
    });

     // Add click listeners to Signal/Suggestion cells for row highlight
    document.querySelectorAll('#body .signal-suggestion.clickable').forEach(c => {
        c.onclick = () => {
            const row = c.closest('tr');
            document.querySelectorAll('.highlight-suggestion').forEach(hr => hr.classList.remove('highlight-suggestion'));
            row.classList.add('highlight-suggestion');
            // Optional: Populate buy/sell based on suggestion click
            // const lastPriceCell = row.querySelector('.last.clickable');
            // if (lastPriceCell) {
            //     const suggestionText = row.querySelector('.suggestion-text').textContent;
            //     if (suggestionText.includes('Buy')) { document.getElementById('buy').value = lastPriceCell.textContent; document.getElementById('sell').value = ''; }
            //     else if (suggestionText.includes('Sell')) { document.getElementById('sell').value = lastPriceCell.textContent; document.getElementById('buy').value = ''; }
            //     updateCalc();
            // }
        };
    });

     // NEW: Add event listeners for the toggle-top-coin icons
    document.querySelectorAll('#body .toggle-top-coin').forEach(icon => {
        icon.onclick = (event) => {
            event.stopPropagation(); // Prevent row click event from firing
            const symbol = icon.dataset.symbol;
            if (symbol) {
                toggleTopCoin(symbol);
            }
        };
    });
  }

  // --- UI Control Functions ---

  // RSI Interval Selection
  function selectRsiInterval(buttonElement) {
      const newInterval = buttonElement.dataset.interval; if (newInterval === currentRsiInterval) return;
      currentRsiInterval = newInterval;
      document.querySelectorAll('.btn-rsi').forEach(btn => btn.classList.remove('active'));
      buttonElement.classList.add('active');
      const rsiHeader = document.getElementById('rsiHeader'); if (rsiHeader) rsiHeader.textContent = `RSI (${currentRsiInterval})`;
      const tableBody = document.getElementById('body'); if (tableBody) tableBody.innerHTML = `<tr><td colspan="9" class="text-center p-4 text-gray-500">Loading ${currentRsiInterval} RSI data...</td></tr>`; // Updated colspan
      // Clear existing refresh timeout and load data immediately
      if (dataRefreshTimeoutId) clearTimeout(dataRefreshTimeoutId);
      loadData(); // Load data immediately after changing interval
  }

  // Page View Selection
  function selectPage(buttonElement) {
      const newPage = buttonElement.dataset.page; if (newPage === currentPage) return;
      currentPage = newPage;
      document.querySelectorAll('.btn-page').forEach(btn => btn.classList.remove('active'));
      buttonElement.classList.add('active');

      // Clear any existing refresh timeout
      if (dataRefreshTimeoutId) clearTimeout(dataRefreshTimeoutId);

      // Update auto-refresh state and display based on the selected page
      const refreshDisplay = document.getElementById('refresh-interval-display');
      const refreshOnBtn = document.getElementById('refresh-on-btn');
      const refreshOffBtn = document.getElementById('refresh-off-btn');
      const rateLimitWarning = document.getElementById('rate-limit-warning');


      if (newPage === 'top4') {
          isAutoRefreshEnabled = true; // Enable auto-refresh for Top Coins
          refreshDisplay.textContent = 'Auto Refresh: 5s';
           document.getElementById('rate-limit-warning').classList.remove('hidden'); // Show warning for high frequency
          refreshOnBtn.classList.add('active');
          refreshOffBtn.classList.remove('active');
          // Schedule the next refresh for Top Coins
          scheduleNextRefresh();
      } else { // newPage === 'all'
          isAutoRefreshEnabled = false; // Disable auto-refresh for All Coins
          refreshDisplay.textContent = 'Auto Refresh: OFF';
          rateLimitWarning.classList.add('hidden'); // Hide warning for lower frequency
          refreshOnBtn.classList.remove('active');
          refreshOffBtn.classList.add('active');
          // No need to schedule, as isAutoRefreshEnabled is false
      }

      renderTable(); // Re-render the table immediately with the new page filter

      // Note: loadData is NOT called immediately here to avoid unnecessary API calls on page switch.
      // The data for the new page will be rendered from the existing allTableData.
      // A manual refresh can be triggered by the user if needed.
  }

  // Function for manual refresh
  function manualRefresh() {
      console.log("Manual Refresh triggered.");
      updateErrorDisplay(''); // Clear errors on manual refresh
      document.getElementById('rate-limit-warning').classList.add('hidden'); // Hide warning

      // Clear any pending scheduled refreshes for coin data and global metrics
      if (dataRefreshTimeoutId) clearTimeout(dataRefreshTimeoutId);
      if (globalMetricsIntervalId) clearInterval(globalMetricsIntervalId);

      // Perform immediate refresh
      loadGlobalMetrics();
      loadData(); // loadData will call scheduleNextRefresh if auto-refresh is enabled

      // Restart the global metrics automatic refresh interval if enabled
      if (isAutoRefreshEnabled) {
          startGlobalMetricsRefresh();
      }
      // Note: loadData already handles scheduling the *next* coin data refresh if enabled.
  }

  // Function to stop auto-refresh
  function stopAutoRefresh() {
      console.log("Auto Refresh OFF");
      isAutoRefreshEnabled = false;
      if (dataRefreshTimeoutId) clearTimeout(dataRefreshTimeoutId);
      if (globalMetricsIntervalId) clearInterval(globalMetricsIntervalId);
      document.getElementById('refresh-on-btn').classList.remove('active');
      document.getElementById('refresh-off-btn').classList.add('active');
      document.getElementById('refresh-interval-display').textContent = 'Auto Refresh: OFF';
      document.getElementById('rate-limit-warning').classList.add('hidden'); // Hide warning when off
  }

   // Function to start auto-refresh
  function startAutoRefresh() {
      console.log("Auto Refresh ON");
      isAutoRefreshEnabled = true;
      document.getElementById('refresh-on-btn').classList.add('active');
      document.getElementById('refresh-off-btn').classList.remove('active');

      // Update refresh interval display based on current page
      const refreshDisplay = document.getElementById('refresh-interval-display');
      if (currentPage === 'top4') {
          refreshDisplay.textContent = 'Auto Refresh: 5s';
           document.getElementById('rate-limit-warning').classList.remove('hidden'); // Show warning for high frequency
      } else {
          refreshDisplay.textContent = 'Auto Refresh: 15m';
          document.getElementById('rate-limit-warning').classList.add('hidden'); // Hide warning for lower frequency
      }

      // Schedule the next refreshes
      startGlobalMetricsRefresh();
      scheduleNextRefresh();
  }


  // --- Refresh Scheduling ---
  function scheduleNextRefresh() {
      // Clear any existing scheduled refresh for coin data
      if (dataRefreshTimeoutId) {
          clearTimeout(dataRefreshTimeoutId);
      }

      // Only schedule if auto-refresh is enabled for the *current* page
      if (isAutoRefreshEnabled) {
          // Determine the interval based on the current page
          const interval = currentPage === 'top4' ? REFRESH_INTERVAL_TOP4_MS : REFRESH_INTERVAL_ALL_MS;

          // Schedule the next loadData call
          dataRefreshTimeoutId = setTimeout(loadData, interval);
          console.log(`Next coin data refresh scheduled in ${interval} ms for page: ${currentPage}`); // Optional: for debugging
      } else {
           console.log(`Auto Refresh is OFF for page: ${currentPage}. No refresh scheduled.`);
      }
  }

  // Function to start the global metrics refresh interval
  function startGlobalMetricsRefresh() {
      // Clear any existing global metrics interval
      if (globalMetricsIntervalId) {
          clearInterval(globalMetricsIntervalId);
      }

      // Only schedule if auto-refresh is enabled
      if (isAutoRefreshEnabled) {
          // Schedule loadGlobalMetrics to run at the specified interval
          globalMetricsIntervalId = setInterval(loadGlobalMetrics, REFRESH_INTERVAL_GLOBAL_MS);
          console.log(`Global metrics refresh scheduled every ${REFRESH_INTERVAL_GLOBAL_MS} ms.`);
      }
  }


  // --- Initial Load ---
  document.addEventListener('DOMContentLoaded', () => {
      console.log("DOM fully loaded and parsed");

      loadDarkModeSetting(); // Load dark mode setting from localStorage

      loadCoins(); // Load coins and topCoins from localStorage or use defaults
      updateCalc(); // Ensure calculator is updated initially
      populateManualCoinSelect(); // Populate all manual coin dropdowns and set defaults

      // Load saved data for all manual calculators
      for (let i = 1; i <= 5; i++) {
          loadManualCalcData(i);
      }

      // Perform initial loads
      loadGlobalMetrics(); // Initial load of global metrics
      loadData(); // Initial load of coin data (this will call renderTable and updateAllManualCalcs)

      addTableEventListeners(); // Add initial listeners (will be re-added in renderTable)

      // Set initial state of refresh buttons and schedule intervals if enabled (default)
      // Auto-refresh is ON by default for the initial 'top4' page
      isAutoRefreshEnabled = true;
      startGlobalMetricsRefresh(); // Start global metrics refresh
      // scheduleNextRefresh(); // loadData already schedules the first refresh
      document.getElementById('refresh-on-btn').classList.add('active'); // Set ON button active initially
      document.getElementById('refresh-off-btn').classList.remove('active'); // Set OFF button inactive
      document.getElementById('refresh-interval-display').textContent = 'Auto Refresh: 5s';
      document.getElementById('rate-limit-warning').classList.remove('hidden'); // Show warning for high frequency

      // Add event listeners for Add/Remove buttons (Reset button removed)
      document.getElementById('addCoinBtn').addEventListener('click', addCoin);
      document.getElementById('removeCoinBtn').addEventListener('click', removeCoin);
      // Removed event listener for resetCoinsBtn

      // Add event listener for the Dark Mode toggle button
      document.getElementById('darkModeToggle').addEventListener('click', toggleDarkMode);

       // Initial update for all manual calculators and table inline profits after DOM is ready and defaults are set
       // updateAllManualCalcs(); // This is now called by loadData after coin data is available
  });

</script>
</body>
</html>
